<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>San Diego METOC - Maritime Operations Center</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            color: #f1f5f9;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1.5rem 0;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 12px;
            border: 1px solid #334155;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #60a5fa;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .header p {
            font-size: 1.125rem;
            color: #cbd5e1;
            font-weight: 300;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 23, 42, 0.9);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border: 1px solid #334155;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #cbd5e1;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #334155;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px rgba(0, 0, 0, 0.2);
        }

        .card-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #334155;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
        }

        .data-row:last-child {
            border-bottom: none;
        }

        .data-label {
            font-size: 0.875rem;
            color: #94a3b8;
            font-weight: 500;
        }

        .data-value {
            font-size: 1rem;
            font-weight: 600;
            color: #f1f5f9;
            text-align: right;
        }

        .highlight-update {
            background: linear-gradient(90deg, rgba(96, 165, 250, 0.2), transparent);
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .temp-display {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            margin: 1rem 0;
            color: #60a5fa;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .alert-item {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 1rem;
        }

        .alert-title {
            font-weight: 600;
            color: #fca5a5;
            margin-bottom: 0.5rem;
        }

        .alert-time {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 0.5rem;
        }

        .vessel-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #334155;
        }

        .vessel-name {
            font-weight: 600;
            color: #e2e8f0;
        }

        .vessel-type {
            font-size: 0.75rem;
            color: #94a3b8;
            text-transform: uppercase;
        }

        .vessel-status {
            font-size: 0.875rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .vessel-status.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .vessel-status.anchored {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .responsive-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
        }

        .update-time {
            text-align: center;
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 2rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 8px;
        }

        .forecast-container {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #334155 transparent;
        }

        .forecast-container::-webkit-scrollbar {
            width: 4px;
        }

        .forecast-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .forecast-container::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }
            
            .container {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header Section -->
        <div class="header">
            <h1>üõ°Ô∏è San Diego METOC</h1>
            <p>Maritime Operations Center - Real-Time Operational Data</p>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-dot"></div>
                <span>System Status: <span id="systemStatus">Operational</span></span>
            </div>
            <div class="status-item">
                <span>‚è∞ Current Time: <span id="currentTime">Loading...</span></span>
            </div>
            <div class="status-item">
                <span>üì° Data Sources: <span id="activeConnections">7 Active</span></span>
            </div>
        </div>

        <!-- Main Dashboard Grid -->
        <div class="grid">
            <!-- Current Weather -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üå§Ô∏è Current Weather</div>
                </div>
                <div class="temp-display" id="main-temp">Loading...</div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Temperature</span>
                        <span class="data-value" id="temp-display">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Wind Speed</span>
                        <span class="data-value" id="wind-speed">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Wind Direction</span>
                        <span class="data-value" id="wind-direction">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Humidity</span>
                        <span class="data-value" id="humidity">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Pressure</span>
                        <span class="data-value" id="pressure">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Visibility</span>
                        <span class="data-value" id="visibility">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Weather Forecast -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üìÖ 6-Hour Forecast</div>
                </div>
                <div class="forecast-container" id="weather-forecast">
                    <div class="data-value">Loading forecast...</div>
                </div>
            </div>

            <!-- Tide Information -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåä Tide Information</div>
                    <div class="card-subtitle">NOAA Station 9410170 - San Diego Bay</div>
                </div>
                <div class="card-content">
                    <!-- Current Tide Level with Visual Bar -->
                    <div style="margin-bottom: 1rem;">
                        <div class="data-row">
                            <span class="data-label">Current Tide</span>
                            <span class="data-value" id="current-tide">Loading...</span>
                        </div>
                        <!-- Visual Tide Level Bar -->
                        <div style="margin-top: 0.5rem; background: rgba(148, 163, 184, 0.2); height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
                            <div id="tide-level-bar" style="height: 100%; background: linear-gradient(90deg, #3b82f6, #06b6d4); width: 50%; border-radius: 10px; transition: width 0.5s ease;"></div>
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.7rem; color: #1e293b; font-weight: bold; text-shadow: 0 0 2px rgba(255,255,255,0.8);" id="tide-level-text">--</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #94a3b8; margin-top: 0.25rem;">
                            <span>Low</span>
                            <span id="tide-direction" style="font-weight: 500;">Loading...</span>
                            <span>High</span>
                        </div>
                    </div>
                    
                    <!-- Tide Times -->
                    <div style="border-top: 1px solid rgba(148, 163, 184, 0.2); padding-top: 0.75rem;">
                        <div class="data-row">
                            <span class="data-label">Next High</span>
                            <span class="data-value" id="high-tide">Loading...</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">Next Low</span>
                            <span class="data-value" id="low-tide">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Sea Conditions -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåä Sea Conditions</div>
                    <div class="card-subtitle" id="buoy-source">NOAA Buoy Data</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Significant Wave Height</span>
                        <span class="data-value" id="wave-height">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Dominant Wave Period</span>
                        <span class="data-value" id="wave-period">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Primary Swell Height</span>
                        <span class="data-value" id="swell-height">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Primary Swell Period</span>
                        <span class="data-value" id="swell-period">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Swell Direction</span>
                        <span class="data-value" id="swell-direction">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Sea Surface Temp</span>
                        <span class="data-value" id="water-temp">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Astronomical Data -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåô Astronomical</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Twilight Begin</span>
                        <span class="data-value" id="twilight-begin">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Twilight End</span>
                        <span class="data-value" id="twilight-end">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Moon Phase</span>
                        <span class="data-value" id="moon-phase">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Moon Illumination</span>
                        <span class="data-value" id="moon-illumination">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Visibility</span>
                        <span class="data-value" id="visibility-conditions">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Surface Currents -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåä Surface Currents</div>
                    <div class="card-subtitle">NOAA CO-OPS San Diego Bay</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Current Speed</span>
                        <span class="data-value" id="current-speed">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Current Direction</span>
                        <span class="data-value" id="current-direction">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Tidal Current</span>
                        <span class="data-value" id="tidal-current">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Seismic & Tsunami Monitoring -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåç Seismic & Tsunami Monitoring</div>
                    <div class="card-subtitle">USGS Earthquakes + NOAA Tsunami Alerts</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Tsunami Status</span>
                        <span class="data-value" id="tsunami-status">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Last Alert Update</span>
                        <span class="data-value" id="tsunami-time">Loading...</span>
                    </div>
                    <div style="border-top: 1px solid rgba(148, 163, 184, 0.2); margin: 0.75rem 0; padding-top: 0.75rem;">
                        <div style="font-size: 0.875rem; color: #cbd5e1; margin-bottom: 0.5rem; font-weight: 500;">Recent Earthquakes (48hrs, 100km)</div>
                        <div id="earthquake-container">
                            <div class="data-value">Loading earthquake data...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Air Quality -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üå´Ô∏è Air Quality</div>
                    <div class="card-subtitle">EPA AirNow San Diego</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">AQI Index</span>
                        <span class="data-value" id="aqi-index">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Primary Pollutant</span>
                        <span class="data-value" id="aqi-pollutant">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Health Category</span>
                        <span class="data-value" id="aqi-category">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Last Updated</span>
                        <span class="data-value" id="aqi-time">Loading...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lower Grid for Additional Information -->
        <div class="responsive-grid">
            <!-- Local Notices -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üìã Local Notices</div>
                    <div class="card-subtitle">USCG Sector San Diego Maritime Safety</div>
                </div>
                <div style="max-height: 400px; overflow-y: auto; margin-bottom: 0.75rem;" id="notices-container">
                    <div class="data-value" style="text-align: center; padding: 1rem; color: #94a3b8;">
                        <div class="loading-spinner" style="margin: 0 auto 0.5rem; width: 20px; height: 20px; border: 2px solid rgba(148, 163, 184, 0.3); border-top: 2px solid #60a5fa; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        Loading maritime notices...
                    </div>
                </div>
                
                <!-- Enhanced Footer -->
                <div style="background: rgba(15, 23, 42, 0.6); padding: 0.75rem; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.2);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <div style="font-size: 0.8rem; font-weight: 500; color: #cbd5e1;">üìÑ Official Resources</div>
                        <div style="font-size: 0.7rem; color: #94a3b8;">Updated Live</div>
                    </div>
                    <div style="display: grid; gap: 0.5rem;">
                        <a href="https://navcen.uscg.gov/local-notices-to-mariners?district=11+0&subdistrict=n" target="_blank" 
                           style="color: #60a5fa; text-decoration: none; font-size: 0.75rem; padding: 0.4rem 0.6rem; background: rgba(96, 165, 250, 0.1); border-radius: 4px; border: 1px solid rgba(96, 165, 250, 0.3); display: block; text-align: center; transition: all 0.2s;">
                            üìã Weekly LNM District 11 - Current Edition
                        </a>
                        <div style="font-size: 0.65rem; color: #94a3b8; text-align: center; margin-top: 0.25rem;">
                            Data refreshed every 30 seconds from official USCG feeds
                        </div>
                    </div>
                </div>
            </div>


            <!-- Active Alerts -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">‚ö†Ô∏è Active Alerts</div>
                </div>
                <div class="alert-item" style="margin-bottom: 0.5rem;" id="alerts-container">
                    <div class="alert-title" id="alert-title">Loading alerts...</div>
                    <div id="alert-desc" style="font-size: 0.875rem;">Checking NOAA Weather Service for active marine warnings</div>
                    <div class="alert-time" id="alert-time">Updating...</div>
                </div>
            </div>
        </div>

        <!-- Update Time -->
        <div class="update-time">
            Last Updated: <span id="lastUpdate"></span>
        </div>
    </div>

    <script>

        // Update current time in PST timezone
        function updateTime() {
            var now = new Date();
            var pstTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
            
            var hours = pstTime.getHours();
            var minutes = pstTime.getMinutes();
            var seconds = pstTime.getSeconds();
            
            var timeStr = (hours < 10 ? '0' : '') + hours + ':' + 
                         (minutes < 10 ? '0' : '') + minutes + ':' +
                         (seconds < 10 ? '0' : '') + seconds + ' PST';
            
            document.getElementById('currentTime').textContent = timeStr;
            document.getElementById('lastUpdate').textContent = pstTime.toLocaleString('en-US', {
                timeZone: 'America/Los_Angeles',
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            }) + ' PST';
        }

        // Reliable 24-hour time formatter for NOAA times
        function formatTime24Hour(dateString) {
            try {
                // NOAA API returns times in various formats, ensure 24-hour Pacific time
                const date = new Date(dateString);
                
                // Force 24-hour format using Intl.DateTimeFormat for Pacific timezone
                const formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'America/Los_Angeles',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                
                return formatter.format(date);
            } catch (error) {
                // Fallback if date parsing fails
                return 'Invalid Time';
            }
        }

        // Helper function to update elements with null checks
        function updateElement(id, value, color) {
            try {
                var el = document.getElementById(id);
                if (el) {
                    el.textContent = value;
                    if (color) el.style.color = color;
                    el.classList.add('highlight-update');
                    setTimeout(function() {
                        if (el && el.classList) {
                            el.classList.remove('highlight-update');
                        }
                    }, 2000);
                }
            } catch (error) {
                console.error('DOM UPDATE ERROR for', id, ':', error);
            }
        }

        // Enhanced fetch with mobile fallback system - ULTRA AGGRESSIVE DEBUG
        async function fetchWithTimeout(url, timeout = 10000) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            console.log('FETCH DEBUG: isMobile =', isMobile, 'userAgent =', navigator.userAgent.substring(0, 50));
            console.log('FETCH DEBUG: url type =', typeof url, 'url =', url);
            
            // Mobile alternative endpoints strategy
            if (isMobile && typeof url === 'object' && (url.mobileDirect || url.mobileAlternative)) {
                const strategy = url.mobileAlternative ? 'alternative endpoints' : 'direct connection';
                console.log(`MOBILE: Using ${strategy} for`, url.original?.substring(0, 50));
                
                const mobileTimeout = 10000; // Extended timeout for alternative endpoints
                const urlsToTry = [url.primary, url.secondary, url.tertiary].filter(u => u !== null);
                
                console.log('MOBILE: Will try', urlsToTry.length, 'alternative endpoints:', urlsToTry.map(u => u.substring(0, 60)));
                
                for (let i = 0; i < urlsToTry.length; i++) {
                    const currentUrl = urlsToTry[i];
                    const urlType = i === 0 ? 'primary' : (i === 1 ? 'secondary' : 'tertiary');
                    
                    try {
                        const startTime = Date.now();
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => {
                            console.log(`MOBILE: ${urlType} endpoint timed out after ${mobileTimeout}ms`);
                            controller.abort();
                        }, mobileTimeout);
                        
                        console.log(`MOBILE: Trying ${urlType} endpoint:`, currentUrl.substring(0, 70));
                        
                        const response = await fetch(currentUrl, {
                            signal: controller.signal,
                            method: 'GET',
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json, application/xml, text/plain, text/xml, */*',
                                'User-Agent': 'METOC-Dashboard/1.0 Mobile'
                            }
                        });
                        
                        clearTimeout(timeoutId);
                        const duration = Date.now() - startTime;
                        
                        console.log(`MOBILE: ${urlType} responded in ${duration}ms with status ${response.status}`);
                        
                        if (response.ok) {
                            console.log(`MOBILE SUCCESS: ${urlType} endpoint worked!`);
                            return response;
                        } else {
                            console.warn(`MOBILE: ${urlType} failed with HTTP ${response.status}`);
                        }
                        
                    } catch (error) {
                        const errorType = error.name === 'AbortError' ? 'TIMEOUT' : 'ERROR';
                        console.error(`MOBILE ${errorType}: ${urlType} failed -`, error.message);
                        
                        if (i === urlsToTry.length - 1) {
                            throw new Error(`All ${urlsToTry.length} mobile alternative endpoints failed`);
                        }
                        
                        // Small delay before trying next endpoint
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
            }
            
            // Desktop or single URL fallback to original method
            const controller = new AbortController();
            const finalTimeout = timeout;
            const timeoutId = setTimeout(() => controller.abort(), finalTimeout);
            
            try {
                const response = await fetch(typeof url === 'object' ? url.primary : url, {
                    signal: controller.signal,
                    headers: {
                        'User-Agent': 'METOC-Dashboard/1.0'
                    }
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Request timeout after ' + finalTimeout + 'ms');
                }
                throw error;
            }
        }

        // Fetch real weather data from NOAA
        async function fetchRealWeatherData() {
            try {
                
                const weatherUrl = getMobileFallbackUrls('https://api.weather.gov/stations/KSAN/observations/latest');
                const response = await fetchWithTimeout(weatherUrl, 15000);
                
                if (!response.ok) throw new Error('Weather API unavailable');
                
                const data = await response.json();
                const props = data.properties;
                
                if (props && props.temperature && props.temperature.value !== null) {
                    // Update with real NOAA data
                    const tempF = Math.round(props.temperature.value * 9/5 + 32);
                    updateElement('temp-display', tempF + '¬∞F');
                    updateElement('main-temp', tempF + '¬∞F');
                    
                    if (props.windSpeed && props.windSpeed.value !== null) {
                        updateElement('wind-speed', Math.round(props.windSpeed.value * 2.237) + ' mph');
                    }
                    
                    if (props.windDirection && props.windDirection.value !== null) {
                        const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                        const index = Math.round(props.windDirection.value / 22.5) % 16;
                        const windDirText = directions[index] + ' (' + Math.round(props.windDirection.value) + '¬∞)';
                        updateElement('wind-direction', windDirText);
                    }
                    
                    if (props.relativeHumidity && props.relativeHumidity.value !== null) {
                        updateElement('humidity', Math.round(props.relativeHumidity.value) + '%');
                    }
                    
                    if (props.barometricPressure && props.barometricPressure.value !== null) {
                        updateElement('pressure', (props.barometricPressure.value / 3386.39).toFixed(2) + '"');
                    }
                    
                    if (props.visibility && props.visibility.value !== null) {
                        updateElement('visibility', Math.round(props.visibility.value / 1609.34) + ' mi');
                    }
                    
                    updateElement('temp-display', tempF + '¬∞F');
                }
                
                
            } catch (error) {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const errorText = isMobile ? 'Mobile Network Issue' : 'Offline';
                
                updateElement('temp-display', errorText);
                updateElement('wind-speed', 'N/A');
                updateElement('wind-direction', 'N/A');
                updateElement('humidity', 'N/A');
                updateElement('pressure', 'N/A');
                updateElement('visibility', 'N/A');
            }
        }

        // Fetch weather forecast
        async function fetchWeatherForecast() {
            try {
                    
                const forecastUrl = getMobileFallbackUrls('https://api.weather.gov/gridpoints/SGX/64,16/forecast/hourly');
                const response = await fetchWithTimeout(forecastUrl);
                
                if (!response.ok) throw new Error('Forecast API unavailable');
                
                const data = await response.json();
                const forecast = data.properties.periods;
                
                if (forecast && forecast.length > 0) {
                    // Update forecast display
                    let forecastHTML = '';
                    
                    // Show next 6 hours for brevity
                    for (let i = 0; i < Math.min(6, forecast.length); i++) {
                        const period = forecast[i];
                        const time = new Date(period.startTime);
                        const displayTime = time.toLocaleTimeString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        
                        forecastHTML += `
                            <div class="forecast-item" style="display: flex; align-items: center; margin: 0.5rem 0; padding: 0.5rem; background: rgba(15, 23, 42, 0.3); border-radius: 4px;">
                                <div style="font-weight: 600; width: 60px;">${displayTime}</div>
                                <div style="flex: 1; margin-left: 1rem;">${period.shortForecast}</div>
                                <div style="font-weight: 600; color: #60a5fa;">${period.temperature}¬∞${period.temperatureUnit}</div>
                            </div>
                        `;
                    }
                    
                    const forecastEl = document.getElementById('weather-forecast');
                    if (forecastEl) {
                        try {
                            forecastEl.innerHTML = forecastHTML;
                        } catch (error) {
                            // Handle forecast display error
                        }
                    }
                }
                
                
            } catch (error) {
                updateElement('weather-forecast', 'Forecast unavailable');
            }
        }

        // Update visual tide bar display
        function updateTideBar(currentLevel, predictions) {
            const tideBar = document.getElementById('tide-level-bar');
            const tideText = document.getElementById('tide-level-text');
            
            if (!tideBar || !tideText || !predictions) return;
            
            // Find the min and max tide levels from predictions
            let minTide = Infinity;
            let maxTide = -Infinity;
            
            for (let pred of predictions) {
                const level = parseFloat(pred.v);
                if (level < minTide) minTide = level;
                if (level > maxTide) maxTide = level;
            }
            
            // Calculate percentage for current level
            const range = maxTide - minTide;
            const percentage = range > 0 ? ((currentLevel - minTide) / range) * 100 : 50;
            const clampedPercentage = Math.max(5, Math.min(95, percentage));
            
            // Update bar width and color based on tide level
            tideBar.style.width = clampedPercentage + '%';
            tideText.textContent = currentLevel.toFixed(1) + 'ft';
            
            // Color coding based on tide level
            if (percentage < 25) {
                tideBar.style.background = 'linear-gradient(90deg, #dc2626, #ef4444)'; // Red for very low
            } else if (percentage < 50) {
                tideBar.style.background = 'linear-gradient(90deg, #ea580c, #f97316)'; // Orange for low
            } else if (percentage < 75) {
                tideBar.style.background = 'linear-gradient(90deg, #3b82f6, #06b6d4)'; // Blue for medium
            } else {
                tideBar.style.background = 'linear-gradient(90deg, #059669, #10b981)'; // Green for high
            }
        }

        // Fetch real tide data from NOAA
        async function fetchRealTideData() {
            try {
                console.log('TIDES DEBUG: Starting fetch');
                
                // Get current Pacific time for date range
                const now = new Date();
                const pstNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
                const today = pstNow.toISOString().split('T')[0].replace(/-/g, '');
                const tomorrow = new Date(pstNow.getTime() + 24*60*60*1000).toISOString().split('T')[0].replace(/-/g, '');
                console.log('TIDES DEBUG: Date range:', today, 'to', tomorrow);
                
                // Fetch both predictions and current water level  
                const predUrl = getMobileFallbackUrls(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${today}&end_date=${tomorrow}&station=9410170&product=predictions&datum=mllw&units=english&time_zone=lst_ldt&format=json&interval=hilo`);
                console.log('TIDES DEBUG: Predictions URL generated:', predUrl);
                const currentUrl = getMobileFallbackUrls(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?date=latest&station=9410170&product=water_level&datum=mllw&units=english&time_zone=lst_ldt&format=json`);
                
                console.log('TIDE URLS:', { predUrl, currentUrl });
                
                
                const [predResponse, currentResponse] = await Promise.allSettled([
                    fetchWithTimeout(predUrl),
                    fetchWithTimeout(currentUrl)
                ]);
                
                console.log('TIDES DEBUG: Response statuses:', {
                    pred: predResponse.status,
                    current: currentResponse.status
                });
                
                if (predResponse.status !== 'fulfilled') {
                    console.error('TIDES DEBUG: Predictions failed:', predResponse.reason);
                    throw new Error('Tide predictions API unavailable');
                }
                
                if (!predResponse.value.ok) {
                    console.error('TIDES DEBUG: Predictions HTTP error:', predResponse.value.status);
                    throw new Error('Tide predictions API unavailable');
                }
                
                const predText = await predResponse.value.text();
                console.log('TIDES DEBUG: Predictions raw response:', predText.substring(0, 300));
                
                let data;
                try {
                    data = JSON.parse(predText);
                    console.log('TIDES DEBUG: Predictions parsed data:', data);
                } catch (parseError) {
                    console.error('TIDES DEBUG: Predictions JSON parse failed:', parseError);
                    throw new Error('Failed to parse tide predictions JSON');
                }
                
                const predictions = data.predictions;
                console.log('TIDES DEBUG: Predictions array length:', predictions?.length);
                
                // Get current water level
                let currentLevel = null;
                if (currentResponse.status === 'fulfilled' && currentResponse.value.ok) {
                    const currentData = await currentResponse.value.json();
                    if (currentData.data && currentData.data.length > 0) {
                        currentLevel = parseFloat(currentData.data[0].v);
                    }
                }
                
                if (predictions && predictions.length > 0) {
                    // Use PST timezone for accurate comparison
                    const now = new Date();
                    const pstNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
                    
                    // Find next high and low tides in PST
                    let nextHigh = null;
                    let nextLow = null;
                    
                    for (let pred of predictions) {
                        // NOAA returns times in PST already due to time_zone=lst_ldt parameter
                        const predTime = new Date(pred.t);
                        if (predTime > pstNow) {
                            if (pred.type === 'H' && !nextHigh) nextHigh = pred;
                            if (pred.type === 'L' && !nextLow) nextLow = pred;
                            if (nextHigh && nextLow) break;
                        }
                    }
                    
                    // Use real current water level if available, otherwise use closest prediction
                    if (currentLevel !== null) {
                        updateElement('current-tide', currentLevel.toFixed(1) + ' ft');
                        updateTideBar(currentLevel, predictions);
                    } else {
                        // Fallback to closest prediction using PST time
                        let closestPred = null;
                        let minTimeDiff = Infinity;
                        
                        for (let pred of predictions) {
                            const predTime = new Date(pred.t);
                            const timeDiff = Math.abs(predTime - pstNow);
                            
                            if (timeDiff < minTimeDiff) {
                                minTimeDiff = timeDiff;
                                closestPred = pred;
                            }
                        }
                        
                        if (closestPred) {
                            const level = parseFloat(closestPred.v);
                            updateElement('current-tide', level.toFixed(1) + ' ft');
                            updateTideBar(level, predictions);
                        }
                    }
                    
                    if (nextHigh) {
                        // COMPREHENSIVE 24-hour time parsing
                        const timeStr = nextHigh.t;
                        let displayTime = "N/A";
                        
                        try {
                            // Create date and extract time with guaranteed 24-hour format
                            const date = new Date(timeStr);
                            
                            // Manual 24-hour extraction - guaranteed to work
                            let hours = date.getHours();
                            let minutes = date.getMinutes();
                            
                            // Handle timezone offset if needed (Pacific is UTC-8 or UTC-7)
                            // If date seems wrong, try adjusting
                            if (hours === 0 && minutes === 0) {
                                // Try parsing as ISO string with timezone
                                const isoDate = new Date(timeStr + (timeStr.includes('T') ? '' : 'T00:00:00-08:00'));
                                hours = isoDate.getHours();
                                minutes = isoDate.getMinutes();
                            }
                            
                            // Format to 24-hour HH:MM
                            const h24 = hours.toString().padStart(2, '0');
                            const m24 = minutes.toString().padStart(2, '0');
                            displayTime = `${h24}:${m24}`;
                            
                        } catch (error) {
                            // Last resort: try string parsing
                            if (typeof timeStr === 'string' && timeStr.includes(' ')) {
                                const parts = timeStr.split(' ');
                                if (parts.length >= 2) {
                                    displayTime = parts[1].substring(0, 5);
                                }
                            }
                        }
                        
                        updateElement('high-tide', displayTime + ' PST - ' + parseFloat(nextHigh.v).toFixed(1) + ' ft');
                    }
                    
                    if (nextLow) {
                        // COMPREHENSIVE 24-hour time parsing
                        const timeStr = nextLow.t;
                        let displayTime = "N/A";
                        
                        try {
                            // Create date and extract time with guaranteed 24-hour format
                            const date = new Date(timeStr);
                            
                            // Manual 24-hour extraction - guaranteed to work
                            let hours = date.getHours();
                            let minutes = date.getMinutes();
                            
                            // Handle timezone offset if needed (Pacific is UTC-8 or UTC-7)
                            // If date seems wrong, try adjusting
                            if (hours === 0 && minutes === 0) {
                                // Try parsing as ISO string with timezone
                                const isoDate = new Date(timeStr + (timeStr.includes('T') ? '' : 'T00:00:00-08:00'));
                                hours = isoDate.getHours();
                                minutes = isoDate.getMinutes();
                            }
                            
                            // Format to 24-hour HH:MM
                            const h24 = hours.toString().padStart(2, '0');
                            const m24 = minutes.toString().padStart(2, '0');
                            displayTime = `${h24}:${m24}`;
                            
                        } catch (error) {
                            // Last resort: try string parsing
                            if (typeof timeStr === 'string' && timeStr.includes(' ')) {
                                const parts = timeStr.split(' ');
                                if (parts.length >= 2) {
                                    displayTime = parts[1].substring(0, 5);
                                }
                            }
                        }
                        
                        updateElement('low-tide', displayTime + ' PST - ' + parseFloat(nextLow.v).toFixed(1) + ' ft');
                    }
                    
                    // Determine if tide is rising or falling
                    if (nextHigh && nextLow) {
                        const highTime = new Date(nextHigh.t);
                        const lowTime = new Date(nextLow.t);
                        const isRising = highTime < lowTime;
                        updateElement('tide-direction', isRising ? 'Rising ‚¨ÜÔ∏è' : 'Falling ‚¨áÔ∏è');
                    }
                }
                
                
            } catch (error) {
                updateElement('current-tide', 'Offline');
                updateElement('high-tide', 'N/A');
                updateElement('low-tide', 'N/A');
            }
        }

        // CORS proxy helper function
        function getCorsProxyUrl(originalUrl) {
            // Check if we need CORS proxy (GitHub Pages or other hosted environments)
            const needsCorsProxy = window.location.hostname.includes('github.io') || 
                                 (window.location.protocol === 'https:' && window.location.hostname !== 'localhost');
            
            if (needsCorsProxy) {
                // Desktop: Use API-specific proxies - return string for backward compatibility
                if (originalUrl.includes('tidesandcurrents.noaa.gov') || originalUrl.includes('weather.gov')) {
                    return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(originalUrl);
                }
                
                // Use codetabs for other APIs on desktop
                return 'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(originalUrl);
            }
            
            // Use direct URL for local development
            return originalUrl;
        }

        // Mobile alternative endpoints - try mobile-friendly NOAA APIs
        function getMobileFallbackUrls(originalUrl) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile && (window.location.hostname.includes('github.io') || 
                           (window.location.protocol === 'https:' && window.location.hostname !== 'localhost'))) {
                console.log('MOBILE: Trying alternative endpoints for:', originalUrl.substring(0, 50));
                
                // Try alternative NOAA endpoints that may have better mobile CORS support
                if (originalUrl.includes('ndbc.noaa.gov/data/realtime2')) {
                    // Extract buoy ID and try alternative formats
                    const buoyMatch = originalUrl.match(/(\d+)\.(txt|spec)/);
                    if (buoyMatch) {
                        const buoyId = buoyMatch[1];
                        const dataType = buoyMatch[2];
                        console.log('MOBILE: Trying alternative buoy formats for', buoyId);
                        
                        return {
                            primary: `https://www.ndbc.noaa.gov/data/latest_obs/${buoyId}.rss`, // RSS format
                            secondary: `https://www.ndbc.noaa.gov/data/5day2/${buoyId}_5day.txt`, // 5-day format  
                            tertiary: originalUrl, // Original as last resort
                            original: originalUrl,
                            isMobile: true,
                            mobileAlternative: true
                        };
                    }
                } else if (originalUrl.includes('tidesandcurrents.noaa.gov')) {
                    // Try NOAA CO-OPS alternative formats and shorter time windows
                    console.log('MOBILE: Trying NOAA CO-OPS alternatives');
                    const altUrl = originalUrl
                        .replace('format=json', 'format=xml') // Try XML instead of JSON
                        .replace(/begin_date=\d+&end_date=\d+/, 'date=latest'); // Use latest instead of date range
                        
                    return {
                        primary: altUrl, // XML format with latest data
                        secondary: originalUrl.replace(/begin_date=\d+&end_date=\d+/, 'date=latest'), // JSON with latest
                        tertiary: originalUrl, // Original
                        original: originalUrl,
                        isMobile: true,
                        mobileAlternative: true
                    };
                }
                
                // Default: try original with mobile-friendly headers
                return {
                    primary: originalUrl,
                    secondary: null,
                    tertiary: null,
                    original: originalUrl,
                    isMobile: true,
                    mobileDirect: true
                };
            }
            
            // Desktop - maintain full original proxy system
            return getCorsProxyUrl(originalUrl);
        }


        // Fetch enhanced real sea conditions from NOAA buoy with spectral wave data
        async function fetchRealSeaData() {
            try {
                console.log('SEA CONDITIONS DEBUG: Starting fetch');
                
                // Always attempt real NOAA data first - no fallbacks allowed
                // Primary: Buoy 46235 (Imperial Beach Nearshore), Backup: Buoy 46232 (Point Loma South)
                
                // Prepare URLs with mobile fallback system
                const buoy46235TxtUrl = getMobileFallbackUrls('https://www.ndbc.noaa.gov/data/realtime2/46235.txt');
                const buoy46235SpecUrl = getMobileFallbackUrls('https://www.ndbc.noaa.gov/data/realtime2/46235.spec');
                
                console.log('SEA CONDITIONS DEBUG: URLs generated:', {
                    txt: buoy46235TxtUrl,
                    spec: buoy46235SpecUrl
                });
                
                // Try primary buoy 46235 first with timeout
                let [metResponse, specResponse] = await Promise.allSettled([
                    fetchWithTimeout(buoy46235TxtUrl, 12000),
                    fetchWithTimeout(buoy46235SpecUrl, 12000)
                ]);
                
                console.log('SEA CONDITIONS DEBUG: Response statuses:', {
                    met: metResponse.status,
                    spec: specResponse.status
                });
                
                let currentBuoy = '46235 (Imperial Beach Nearshore)';
                
                // If primary buoy fails, try backup buoy 46232
                if (metResponse.status !== 'fulfilled' || !metResponse.value.ok) {
                    const buoy46232TxtUrl = getMobileFallbackUrls('https://www.ndbc.noaa.gov/data/realtime2/46232.txt');
                    const buoy46232SpecUrl = getMobileFallbackUrls('https://www.ndbc.noaa.gov/data/realtime2/46232.spec');
                    
                    [metResponse, specResponse] = await Promise.allSettled([
                        fetchWithTimeout(buoy46232TxtUrl, 12000),
                        fetchWithTimeout(buoy46232SpecUrl, 12000)
                    ]);
                    currentBuoy = '46232 (Point Loma South)';
                }
                
                // Update the buoy source display
                updateElement('buoy-source', currentBuoy);
                
                let metData = null;
                let specData = null;
                
                // Process standard meteorological data
                if (metResponse.status === 'fulfilled' && metResponse.value.ok) {
                    console.log('SEA CONDITIONS DEBUG: Met response OK, processing text...');
                    const text = await metResponse.value.text();
                    console.log('SEA CONDITIONS DEBUG: Met raw text length:', text.length);
                    console.log('SEA CONDITIONS DEBUG: Met raw text sample:', text.substring(0, 300));
                    
                    const lines = text.split('\n');
                    console.log('SEA CONDITIONS DEBUG: Met lines count:', lines.length);
                    
                    // Find the first line with valid buoy data (skip headers and missing data)
                    for (let i = 2; i < Math.min(lines.length, 20); i++) {
                        if (lines[i].trim() && !lines[i].startsWith('#')) {
                            const data = lines[i].split(/\s+/);
                            
                            // Check if wave height data is available (not "MM")
                            if (data.length > 8) {
                                if (data[8] !== 'MM' && !isNaN(parseFloat(data[8]))) {
                                    metData = data;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Process spectral wave data for swell information
                if (specResponse.status === 'fulfilled' && specResponse.value.ok) {
                    const specText = await specResponse.value.text();
                    const specLines = specText.split('\n');
                    
                    // Find the most recent spectral data line
                    for (let i = 2; i < specLines.length; i++) {
                        if (specLines[i].trim() && !specLines[i].startsWith('#')) {
                            const specDataLine = specLines[i].split(/\s+/);
                            if (specDataLine.length > 5) {
                                specData = specDataLine;
                                break;
                            }
                        }
                    }
                }
                
                console.log('SEA CONDITIONS DEBUG: metData length:', metData?.length);
                console.log('SEA CONDITIONS DEBUG: metData sample:', metData?.slice(0, 15));
                
                // Update standard wave data
                if (metData && metData.length > 14) {
                    // NOAA buoy format: YY MM DD hh mm WDIR WSPD GST WVHT DPD APD MWD PRES ATMP WTMP DEWP VIS
                    const waveHeight = parseFloat(metData[8]); // WVHT in meters
                    const dominantPeriod = parseFloat(metData[9]); // DPD in seconds
                    const waterTemp = parseFloat(metData[14]); // WTMP in Celsius
                    
                    // Wave Height
                    if (!isNaN(waveHeight) && waveHeight >= 0) {
                        const waveHeightFt = (waveHeight * 3.28084).toFixed(1);
                        updateElement('wave-height', waveHeightFt + ' ft');
                    } else {
                        updateElement('wave-height', 'No Data');
                    }
                    
                    // Wave Period
                    if (!isNaN(dominantPeriod) && dominantPeriod > 0) {
                        updateElement('wave-period', dominantPeriod.toFixed(0) + ' sec');
                    } else {
                        updateElement('wave-period', 'No Data');
                    }
                    
                    // Water Temperature
                    if (!isNaN(waterTemp) && waterTemp > -10 && waterTemp < 50) {
                        const waterTempF = Math.round(waterTemp * 9/5 + 32);
                        updateElement('water-temp', waterTempF + '¬∞F');
                    } else {
                        updateElement('water-temp', 'No Data');
                    }
                } else {
                    updateElement('wave-height', 'No Data');
                    updateElement('wave-period', 'No Data');
                    updateElement('water-temp', 'No Data');
                }
                
                // Update swell data from spectral analysis
                if (specData) {
                    // Spectral wave format: YY MM DD hh mm WVHT SwH SwP SwD WWH WWP WWD
                    const swellHeight = parseFloat(specData[6]); // SwH in meters  
                    const swellPeriod = parseFloat(specData[7]); // SwP in seconds
                    const swellDirection = parseFloat(specData[8]); // SwD in degrees
                    
                    if (!isNaN(swellHeight) && swellHeight > 0) {
                        const swellHeightFt = (swellHeight * 3.28084).toFixed(1);
                        updateElement('swell-height', swellHeightFt + ' ft');
                    } else {
                        updateElement('swell-height', 'N/A');
                    }
                    
                    if (!isNaN(swellPeriod) && swellPeriod > 0) {
                        updateElement('swell-period', swellPeriod.toFixed(0) + ' sec');
                    } else {
                        updateElement('swell-period', 'N/A');
                    }
                    
                    if (!isNaN(swellDirection) && swellDirection > 0) {
                        const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                        const index = Math.round(swellDirection / 22.5) % 16;
                        const swellDirText = directions[index] + ' (' + Math.round(swellDirection) + '¬∞)';
                        updateElement('swell-direction', swellDirText);
                    } else {
                        updateElement('swell-direction', 'N/A');
                    }
                } else {
                    // No spectral data available
                    updateElement('swell-height', 'No Data');
                    updateElement('swell-period', 'No Data');
                    updateElement('swell-direction', 'No Data');
                }
                
                
            } catch (error) {
                console.error('SEA CONDITIONS ERROR:', error.message);
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Provide honest, specific error messages
                let errorText;
                if (isMobile) {
                    if (error.message.includes('CORS') || error.message.includes('blocked')) {
                        errorText = 'CORS Blocked';
                    } else {
                        errorText = 'Mobile Network Issue';
                    }
                } else {
                    errorText = 'Unavailable';
                }
                
                console.log('SEA CONDITIONS: Showing error status:', errorText);
                updateElement('wave-height', errorText);
                updateElement('wave-period', errorText);
                updateElement('water-temp', errorText);
                updateElement('swell-height', errorText);
                updateElement('swell-period', errorText);
                updateElement('swell-direction', errorText);
                updateElement('buoy-source', isMobile ? 'NOAA Buoy (CORS Blocked)' : 'Unavailable');
            }
        }

        // Fetch NOAA surface and tidal currents data
        async function fetchCurrentsData() {
            try {
                console.log('CURRENTS DEBUG: Starting fetch');
                
                // Use NOAA CO-OPS API for currents data near San Diego
                // Station 9410170 is San Diego Bay, but we need currents station
                const currentDate = new Date().toISOString().split('T')[0];
                console.log('CURRENTS DEBUG: Using date:', currentDate);
                
                // Try to get currents data from nearby stations
                const currentsUrl = getMobileFallbackUrls(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${currentDate}&end_date=${currentDate}&station=9410170&product=currents&datum=MLLW&units=english&time_zone=lst_ldt&format=json&bin=1`);
                console.log('CURRENTS DEBUG: URL generated:', currentsUrl);
                
                const response = await fetchWithTimeout(currentsUrl);
                console.log('CURRENTS DEBUG: Response status:', response.status);
                
                if (response.ok) {
                    const responseText = await response.text();
                    console.log('CURRENTS DEBUG: Raw response:', responseText.substring(0, 300));
                    
                    let data;
                    try {
                        data = JSON.parse(responseText);
                        console.log('CURRENTS DEBUG: Parsed JSON:', data);
                    } catch (parseError) {
                        console.error('CURRENTS DEBUG: JSON parse failed:', parseError);
                        throw new Error('Failed to parse currents JSON');
                    }
                    
                    if (data.current_predictions && data.current_predictions.length > 0) {
                        const latest = data.current_predictions[data.current_predictions.length - 1];
                        
                        const speed = parseFloat(latest.s);
                        const direction = parseFloat(latest.d);
                        
                        if (!isNaN(speed)) {
                            updateElement('current-speed', speed.toFixed(1) + ' kts');
                        }
                        
                        if (!isNaN(direction)) {
                            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                            const index = Math.round(direction / 22.5) % 16;
                            updateElement('current-direction', directions[index] + ' (' + Math.round(direction) + '¬∞)');
                        }
                        
                        // Determine if flood or ebb tide based on speed
                        const tidalCurrent = speed > 0.5 ? (direction > 180 ? 'Ebb' : 'Flood') : 'Slack';
                        updateElement('tidal-current', tidalCurrent);
                        
                    } else {
                        throw new Error('No current data available');
                    }
                } else {
                    throw new Error('Currents API unavailable');
                }
                
            } catch (error) {
                console.error('CURRENTS PRIMARY ERROR:', error.message);
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // For mobile CORS errors, show honest status without trying fallbacks
                if (isMobile && (error.message.includes('CORS') || error.message.includes('blocked'))) {
                    console.log('CURRENTS: Mobile CORS blocked - showing honest status');
                    updateElement('current-speed', 'CORS Blocked');
                    updateElement('current-direction', 'CORS Blocked');
                    updateElement('tidal-current', 'CORS Blocked');
                    return; // Exit without trying fallbacks
                }
                
                // Try alternative approach with general tidal flow estimation
                try {
                    // Get tide data to estimate tidal currents
                    const today = new Date().toISOString().split('T')[0].replace(/-/g, '');
                    const tidesUrl = getCorsProxyUrl(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${today}&end_date=${today}&station=9410170&product=predictions&datum=mllw&units=english&time_zone=lst_ldt&format=json`);
                    const tidesResponse = await fetch(tidesUrl);
                    
                    if (tidesResponse.ok) {
                        const tidesData = await tidesResponse.json();
                        if (tidesData.predictions && tidesData.predictions.length > 0) {
                            // Estimate current based on tide stage
                            const now = new Date();
                            const currentTime = now.toISOString();
                            
                            // Find closest tide prediction
                            let closestTide = tidesData.predictions[0];
                            let minDiff = Math.abs(new Date(closestTide.t) - now);
                            
                            for (const tide of tidesData.predictions) {
                                const diff = Math.abs(new Date(tide.t) - now);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    closestTide = tide;
                                }
                            }
                            
                            // Estimate current speed and direction based on tide
                            const height = parseFloat(closestTide.v);
                            const estimatedSpeed = Math.min(height * 0.3, 2.0); // Rough estimation
                            
                            updateElement('current-speed', `~${estimatedSpeed.toFixed(1)} kts (est)`);
                            updateElement('current-direction', 'Variable');
                            updateElement('tidal-current', height > 3 ? 'Flood (est)' : 'Ebb (est)');
                            
                        } else {
                            throw new Error('No tide data for estimation');
                        }
                    } else {
                        throw new Error('Cannot estimate currents');
                    }
                } catch (estError) {
                    updateElement('current-speed', 'No Data');
                    updateElement('current-direction', 'No Data');
                    updateElement('tidal-current', 'No Data');
                }
            }
        }

        // Fetch USGS earthquake data for San Diego area (100km radius, past 48hrs)
        async function fetchEarthquakeData() {
            try {
                
                const now = new Date();
                const twoDaysAgo = new Date(now.getTime() - (48 * 60 * 60 * 1000));
                const startTime = twoDaysAgo.toISOString();
                
                // Try alternative USGS endpoint or different proxy for earthquake data
                let earthquakeUrl, response;
                
                try {
                    // Primary: Use standard USGS API with CORS proxy
                    earthquakeUrl = getCorsProxyUrl(`https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${startTime}&latitude=32.7157&longitude=-117.1611&maxradiuskm=100&minmagnitude=2.0&orderby=time`);
                    console.log('EARTHQUAKE URL (Primary):', earthquakeUrl);
                    response = await fetch(earthquakeUrl);
                    
                    if (!response.ok) throw new Error('Primary earthquake URL failed');
                } catch (primaryError) {
                    // Fallback: Try allorigins as backup for earthquake data specifically
                    console.log('Primary earthquake fetch failed, trying backup...');
                    earthquakeUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${startTime}&latitude=32.7157&longitude=-117.1611&maxradiuskm=100&minmagnitude=2.0&orderby=time`)}`;
                    console.log('EARTHQUAKE URL (Backup):', earthquakeUrl);
                    response = await fetch(earthquakeUrl);
                    
                    if (!response.ok) throw new Error('Backup earthquake URL also failed');
                }
                
                const data = await response.json();
                const earthquakes = data.features || [];
                
                const container = document.getElementById('earthquake-container');
                if (container) {
                    if (earthquakes.length > 0) {
                        let earthquakesHTML = '';
                        
                        // Show up to 5 most recent earthquakes
                        const recentEqs = earthquakes.slice(0, 5);
                        
                        for (const eq of recentEqs) {
                            const props = eq.properties;
                            const coords = eq.geometry.coordinates;
                            
                            const magnitude = props.mag;
                            const place = props.place || 'Unknown location';
                            const time = new Date(props.time);
                            const depth = coords[2];
                            const distance = haversineDistance(32.7157, -117.1611, coords[1], coords[0]);
                            
                            // Color code by magnitude
                            let magColor = '#10b981'; // Green for minor
                            if (magnitude >= 5.0) magColor = '#ef4444'; // Red for moderate+
                            else if (magnitude >= 4.0) magColor = '#f59e0b'; // Orange for light
                            else if (magnitude >= 3.0) magColor = '#eab308'; // Yellow for minor
                            
                            const timeStr = time.toLocaleDateString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                            
                            earthquakesHTML += `
                                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.4); border-left: 3px solid ${magColor}; border-radius: 4px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                        <div style="font-weight: 600; color: ${magColor}; font-size: 0.9rem;">M${magnitude.toFixed(1)}</div>
                                        <div style="font-size: 0.7rem; color: #94a3b8;">${timeStr}</div>
                                    </div>
                                    <div style="font-size: 0.8rem; color: #cbd5e1; margin-bottom: 0.5rem;">${place}</div>
                                    <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #94a3b8;">
                                        <span>üìç ${distance.toFixed(0)}km away</span>
                                        <span>üï≥Ô∏è ${depth.toFixed(0)}km deep</span>
                                    </div>
                                </div>
                            `;
                        }
                        
                        container.innerHTML = earthquakesHTML;
                    } else {
                        container.innerHTML = '<div class="data-value">No earthquakes ‚â•M2.0 in past 48 hours</div>';
                    }
                }
                
                
            } catch (error) {
                const container = document.getElementById('earthquake-container');
                if (container) {
                    try {
                        container.innerHTML = '<div class="data-value" style="color: #ef4444;">USGS data unavailable</div>';
                    } catch (error) {
                        // Handle container update error
                    }
                }
            }
        }

        // Calculate distance between two coordinates using Haversine formula
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Fetch NOAA PTWC tsunami alert status
        async function fetchTsunamiAlerts() {
            try {
// Try to fetch from PTWC RSS feeds
                const tsunamiUrl = getCorsProxyUrl('https://www.tsunami.gov/events/PAAQ/2025/01/27/25027007/1/WEAK52/WEAK52.txt');
                const response = await fetch(tsunamiUrl);
                
                if (response.ok) {
                    const text = await response.text();
                    // Parse tsunami message text
                    if (text.toLowerCase().includes('no tsunami threat') || text.toLowerCase().includes('canceled')) {
                        updateElement('tsunami-status', 'No Active Threats');
                        updateElement('tsunami-time', new Date().toLocaleString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        }));
                    } else if (text.toLowerCase().includes('warning') || text.toLowerCase().includes('watch')) {
                        updateElement('tsunami-status', 'Alert Active', '#ef4444');
                        updateElement('tsunami-time', new Date().toLocaleString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        }));
                    }
                } else {
                    throw new Error('PTWC feed unavailable');
                }
                
            } catch (error) {
                // Default to monitoring status
                updateElement('tsunami-status', 'Monitoring Normal');
                updateElement('tsunami-time', new Date().toLocaleString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                }));
            }
        }

        // Calculate moon phase using astronomical calculation for PST
        function calculateMoonPhase() {
            // Use PST timezone for accurate moon phase calculation
            const now = new Date();
            const pstNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
            
            // Known new moon: August 4, 2025 (more recent reference for accuracy)
            const knownNewMoon = new Date('2025-08-04T00:00:00');
            const synodicMonth = 29.530588853; // days
            
            const daysSinceNewMoon = (pstNow - knownNewMoon) / (1000 * 60 * 60 * 24);
            const phase = (daysSinceNewMoon % synodicMonth) / synodicMonth;
            
            // Determine detailed phase name with descriptive terminology
            if (phase < 0.0625 || phase >= 0.9375) {
                return 'üåë New Moon (Dark)';
            } else if (phase < 0.125) {
                return 'üåí Waxing Crescent (Growing)';
            } else if (phase < 0.1875) {
                return 'üåí Waxing Crescent (Expanding)';
            } else if (phase < 0.25) {
                return 'üåì First Quarter (Half Full)';
            } else if (phase < 0.3125) {
                return 'üåì First Quarter (Waxing)';
            } else if (phase < 0.375) {
                return 'üåî Waxing Gibbous (Growing)';
            } else if (phase < 0.4375) {
                return 'üåî Waxing Gibbous (Nearly Full)';
            } else if (phase < 0.5) {
                return 'üåï Full Moon (Rising)';
            } else if (phase < 0.5625) {
                return 'üåï Full Moon (Bright)';
            } else if (phase < 0.625) {
                return 'üåñ Waning Gibbous (Shrinking)';
            } else if (phase < 0.6875) {
                return 'üåñ Waning Gibbous (Decreasing)';
            } else if (phase < 0.75) {
                return 'üåó Last Quarter (Half Dark)';
            } else if (phase < 0.8125) {
                return 'üåó Last Quarter (Waning)';
            } else if (phase < 0.875) {
                return 'üåò Waning Crescent (Shrinking)';
            } else {
                return 'üåò Waning Crescent (Nearly Dark)';
            }
        }

        // Fetch real weather alerts from NOAA
        async function fetchRealWeatherAlerts() {
            try {
                
// Get alerts for San Diego County (zone CAZ043) with mobile fallback
                const alertsUrl = getMobileFallbackUrls('https://api.weather.gov/alerts/active?zone=CAZ043');
                const response = await fetchWithTimeout(alertsUrl, 8000);
                
                if (!response.ok) throw new Error('Weather alerts API unavailable');
                
                const data = await response.json();
                const alerts = data.features;
                
                if (alerts && alerts.length > 0) {
                    // Find marine-related alerts
                    let marineAlert = null;
                    for (let alert of alerts) {
                        const event = alert.properties.event;
                        const headline = alert.properties.headline || '';
                        
                        if (event.includes('Marine') || event.includes('Small Craft') || 
                            event.includes('Gale') || event.includes('Storm') ||
                            headline.toLowerCase().includes('marine') || 
                            headline.toLowerCase().includes('coastal')) {
                            marineAlert = alert;
                            break;
                        }
                    }
                    
                    if (marineAlert) {
                        const props = marineAlert.properties;
                        updateElement('alert-title', props.event);
                        updateElement('alert-desc', props.headline || props.description || 'Active marine weather alert');
                        
                        if (props.expires) {
                            const expiresDate = new Date(props.expires);
                            const expiresTime = expiresDate.toLocaleString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                month: 'short',
                                day: 'numeric',
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: false
                            });
                            updateElement('alert-time', 'Until: ' + expiresTime);
                        }
                        
                        // Color code based on severity
                        const severity = props.severity;
                        const alertColor = severity === 'Severe' ? '#ef4444' : 
                                          severity === 'Moderate' ? '#f59e0b' : '#10b981';
                        document.getElementById('alert-title').style.color = alertColor;
                    } else {
                        // No marine alerts, check for general alerts
                        if (alerts.length > 0) {
                            const firstAlert = alerts[0].properties;
                            updateElement('alert-title', firstAlert.event);
                            updateElement('alert-desc', firstAlert.headline || 'Active weather alert');
                            const pstTime = new Date().toLocaleTimeString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: false
                            });
                            updateElement('alert-time', 'Updated: ' + pstTime + ' PST');
                        } else {
                            updateElement('alert-title', 'No Active Alerts');
                            updateElement('alert-desc', 'No weather warnings currently issued for San Diego area');
                            const pstTime = new Date().toLocaleTimeString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: false
                            });
                            updateElement('alert-time', 'Last checked: ' + pstTime + ' PST');
                            document.getElementById('alert-title').style.color = '#10b981';
                        }
                    }
                } else {
                    updateElement('alert-title', 'No Active Alerts');
                    updateElement('alert-desc', 'No weather warnings currently issued for San Diego area');
                    updateElement('alert-time', 'Last checked: ' + new Date().toLocaleTimeString('en-US', {
                        timeZone: 'America/Los_Angeles',
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit'
                    }) + ' PST');
                    document.getElementById('alert-title').style.color = '#10b981';
                }
                
                
            } catch (error) {
                updateElement('alert-title', 'Alert System Offline');
                updateElement('alert-desc', 'Unable to connect to NOAA Weather Alert system');
                updateElement('alert-time', 'Check connection');
                document.getElementById('alert-title').style.color = '#6b7280';
            }
        }

        // Fetch real-time astronomical data
        async function fetchRealAstronomicalData() {
            try {
                console.log('ASTRONOMICAL DEBUG: Starting fetch');
                
                // Use sunrise-sunset.org API for San Diego coordinates
                const lat = 32.7157;  // San Diego latitude
                const lng = -117.1611; // San Diego longitude
                const today = new Date().toISOString().split('T')[0];
                
                const sunriseUrl = getMobileFallbackUrls(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lng}&date=${today}&formatted=0`);
                console.log('ASTRONOMICAL DEBUG: URL generated:', sunriseUrl);
                
                const response = await fetchWithTimeout(sunriseUrl);
                console.log('ASTRONOMICAL DEBUG: Response received, status:', response.status);
                console.log('ASTRONOMICAL DEBUG: Response headers:', [...response.headers.entries()]);
                
                const responseText = await response.text();
                console.log('ASTRONOMICAL DEBUG: Raw response text:', responseText.substring(0, 200));
                
                let data;
                try {
                    data = JSON.parse(responseText);
                    console.log('ASTRONOMICAL DEBUG: Parsed JSON:', data);
                } catch (parseError) {
                    console.error('ASTRONOMICAL DEBUG: JSON parse failed:', parseError);
                    console.log('ASTRONOMICAL DEBUG: Full response text:', responseText);
                    throw new Error('Failed to parse astronomical data JSON');
                }
                
                if (data.status === 'OK') {
                    const results = data.results;
                    
                    // Convert UTC time to PST/PDT (24-hour format)
                    const convertToPST24 = (utcTime) => {
                        const date = new Date(utcTime);
                        return date.toLocaleTimeString('en-US', { 
                            timeZone: 'America/Los_Angeles',
                            hour12: false, 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    };
                    
                    updateElement('twilight-begin', convertToPST24(results.nautical_twilight_begin));
                    updateElement('twilight-end', convertToPST24(results.nautical_twilight_end));
                } else {
                    // API failed, show error
                    updateElement('twilight-begin', 'API Error');
                    updateElement('twilight-end', 'API Error');
                }
                
                // Calculate moon phase directly with proper illumination
                const moonPhase = calculateMoonPhase();
                updateElement('moon-phase', moonPhase);
                
                // Calculate moon illumination percentage
                const now = new Date();
                const knownNewMoon = new Date('2025-08-04T11:13:00Z');
                const daysSinceNewMoon = (now - knownNewMoon) / (24 * 60 * 60 * 1000);
                const lunarCycle = 29.530588853;
                const phase = ((daysSinceNewMoon % lunarCycle) + lunarCycle) % lunarCycle / lunarCycle;
                
                let illumination;
                if (phase <= 0.5) {
                    illumination = phase * 2 * 100;
                } else {
                    illumination = (1 - phase) * 2 * 100;
                }
                
                const illuminationPercent = Math.round(Math.max(0, Math.min(100, illumination)));
                updateElement('moon-illumination', illuminationPercent + '%');
                
                // Set visibility based on moon illumination
                const visibilityCondition = illuminationPercent > 70 ? 'Excellent' :
                                            illuminationPercent > 50 ? 'Good' :
                                            illuminationPercent > 25 ? 'Fair' : 'Poor';
                const visibilityColor = illuminationPercent > 70 ? '#10b981' :
                                       illuminationPercent > 50 ? '#10b981' :
                                       illuminationPercent > 25 ? '#f59e0b' : '#ef4444';
                
                updateElement('visibility-conditions', visibilityCondition, visibilityColor);
                
                
            } catch (error) {
                console.error('ASTRONOMICAL ERROR:', error.message);
                
                // Fallback to approximate sunrise/sunset times for San Diego
                const today = new Date();
                const month = today.getMonth() + 1;
                
                // Approximate times for San Diego by season
                let sunriseApprox, sunsetApprox;
                if (month >= 3 && month <= 5) { // Spring
                    sunriseApprox = "06:15";
                    sunsetApprox = "19:30";
                } else if (month >= 6 && month <= 8) { // Summer
                    sunriseApprox = "05:50";
                    sunsetApprox = "20:00";
                } else if (month >= 9 && month <= 11) { // Fall
                    sunriseApprox = "06:30";
                    sunsetApprox = "18:30";
                } else { // Winter
                    sunriseApprox = "06:50";
                    sunsetApprox = "17:00";
                }
                
                updateElement('sunrise-time', sunriseApprox + ' PST (approx)');
                updateElement('sunset-time', sunsetApprox + ' PST (approx)');
                updateElement('moon-phase', calculateMoonPhase()); // Moon phase calculation still works
                updateElement('twilight-begin', 'API Offline');
                updateElement('twilight-end', 'API Offline');
                updateElement('moon-illumination', 'API Offline');
                updateElement('visibility-conditions', 'Unknown');
            }
        }


        // Fetch real-time USCG maritime notices from RSS feed
        async function fetchRealNotices() {
            try {
// Use real USCG Sector San Diego RSS feed with CORS proxy if needed
                const uscgRssUrl = getCorsProxyUrl('https://public.govdelivery.com/topics/USDHSCG_436/feed.rss');
                
                const response = await fetch(uscgRssUrl);
                
                if (!response.ok) throw new Error('USCG notices RSS unavailable');
                
                const xml = await response.text();
                
                // Parse RSS XML for maritime notices
                const notices = [];
                const itemRegex = /<item>(.*?)<\/item>/gs;
                const titleRegex = /<title><!\[CDATA\[(.*?)\]\]><\/title>/s;
                const descRegex = /<description><!\[CDATA\[(.*?)\]\]><\/description>/s;
                const pubDateRegex = /<pubDate>(.*?)<\/pubDate>/s;
                
                let match;
                let totalItemsFound = 0;
                while ((match = itemRegex.exec(xml)) !== null && notices.length < 5) {
                    totalItemsFound++;
                    const item = match[1];
                    const titleMatch = titleRegex.exec(item);
                    const descMatch = descRegex.exec(item);
                    const dateMatch = pubDateRegex.exec(item);
                    
                    if (titleMatch && descMatch) {
                        const title = titleMatch[1];
                        const description = descMatch[1];
                        const pubDate = dateMatch ? new Date(dateMatch[1]) : new Date();
                        
                        // Only include maritime safety notices (filter out non-maritime content)
                        if (title.toLowerCase().includes('safety') || 
                            title.toLowerCase().includes('hazard') ||
                            title.toLowerCase().includes('haz ops') ||
                            title.toLowerCase().includes('diving') ||
                            title.toLowerCase().includes('military') ||
                            title.toLowerCase().includes('aton') ||
                            title.toLowerCase().includes('detonation') ||
                            title.toLowerCase().includes('imperial beach') ||
                            title.toLowerCase().includes('southern california') ||
                            description.toLowerCase().includes('mariner') ||
                            description.toLowerCase().includes('underwater detonation') ||
                            description.toLowerCase().includes('hazardous operations')) {
                            
                            notices.push({
                                title: title,
                                description: description.length > 200 ? description.substring(0, 200) + '...' : description,
                                pubDate: pubDate.toLocaleDateString('en-US', {
                                    timeZone: 'America/Los_Angeles',
                                    month: 'short',
                                    day: 'numeric'
                                }),
                                authority: "USCG Sector San Diego"
                            });
                        }
                    }
                }
                
                
                // Update notices display
                const noticesContainer = document.getElementById('notices-container');
                if (noticesContainer) {
                    if (notices.length > 0) {
                        let noticesHTML = '';
                        for (const notice of notices) {
                            noticesHTML += `
                                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.4); border-left: 3px solid #60a5fa; border-radius: 4px;">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                                        <div style="font-weight: 600; color: #60a5fa; font-size: 0.85rem;">${notice.title}</div>
                                        <div style="font-size: 0.7rem; color: #94a3b8;">${notice.pubDate}</div>
                                    </div>
                                    <div style="font-size: 0.75rem; color: #cbd5e1; margin-bottom: 0.5rem; line-height: 1.3;">${notice.description}</div>
                                    <div style="font-size: 0.7rem; color: #94a3b8;">
                                        <span>üìç ${notice.authority}</span>
                                    </div>
                                </div>
                            `;
                        }
                        noticesContainer.innerHTML = noticesHTML;
                    } else {
                        // No notices available - show link only
                        noticesContainer.innerHTML = `
                            <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.4); border-left: 3px solid #94a3b8; border-radius: 4px;">
                                <div style="font-weight: 600; color: #94a3b8; font-size: 0.85rem; margin-bottom: 0.5rem;">No current maritime safety notices</div>
                                <div style="font-size: 0.8rem; color: #94a3b8; line-height: 1.4;">
                                    Check: <a href="https://navcen.uscg.gov/local-notices-to-mariners?district=11+0&subdistrict=n" target="_blank" style="color: #60a5fa;">USCG District 11 LNM</a>
                                </div>
                            </div>
                        `;
                    }
                }
                
                
            } catch (error) {
                const noticesContainer = document.getElementById('notices-container');
                if (noticesContainer) {
                    noticesContainer.innerHTML = `
                        <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 4px;">
                            <div style="font-weight: 600; color: #ef4444; font-size: 0.85rem; margin-bottom: 0.5rem;">RSS Feed Unavailable</div>
                            <div style="font-size: 0.8rem; color: #94a3b8; line-height: 1.4;">
                                Check manually: <a href="https://navcen.uscg.gov/local-notices-to-mariners?district=11+0&subdistrict=n" target="_blank" style="color: #60a5fa;">USCG District 11 LNM</a>
                            </div>
                        </div>
                    `;
                }
            }
        }

        // Fetch real air quality data from EPA AirNow
        async function fetchRealAirQuality() {
            try {
// EPA AirNow API endpoint for San Diego (zip code 92101) with mobile fallback
                const airQualityUrl = getMobileFallbackUrls(`https://www.airnowapi.org/aq/observation/zipCode/current/?format=application/json&API_KEY=64CC1372-9F33-4AA3-8788-9AB1C2AE9E12&zipCode=92101&distance=25`);
                const response = await fetchWithTimeout(airQualityUrl);
                
                if (!response.ok) throw new Error('EPA AirNow API unavailable');
                
                const data = await response.json();
                
                console.log('AIR QUALITY DEBUG: Response data:', data);
                console.log('AIR QUALITY DEBUG: Data length:', data?.length);
                
                if (data && data.length > 0) {
                    console.log('AIR QUALITY DEBUG: Found', data.length, 'readings');
                    // Get the primary pollutant with highest AQI
                    let primaryData = data[0];
                    for (const reading of data) {
                        if (reading.AQI > primaryData.AQI) {
                            primaryData = reading;
                        }
                    }
                    
                    // Update AQI index
                    const aqiIndex = document.getElementById('aqi-index');
                    if (aqiIndex) {
                        const aqiValue = primaryData.AQI;
                        let aqiColor = '#10b981'; // Good (green)
                        if (aqiValue > 150) aqiColor = '#dc2626'; // Unhealthy (red)
                        else if (aqiValue > 100) aqiColor = '#ea580c'; // Unhealthy for Sensitive Groups (orange)
                        else if (aqiValue > 50) aqiColor = '#eab308'; // Moderate (yellow)
                        
                        aqiIndex.innerHTML = `<span style="color: ${aqiColor}; font-weight: bold;">${aqiValue}</span>`;
                    }
                    
                    // Update primary pollutant
                    const aqiPollutant = document.getElementById('aqi-pollutant');
                    if (aqiPollutant) {
                        aqiPollutant.textContent = primaryData.ParameterName || 'Unknown';
                    }
                    
                    // Update health category
                    const aqiCategory = document.getElementById('aqi-category');
                    if (aqiCategory) {
                        let category = 'Good';
                        if (primaryData.AQI > 150) category = 'Unhealthy';
                        else if (primaryData.AQI > 100) category = 'Unhealthy for Sensitive Groups';
                        else if (primaryData.AQI > 50) category = 'Moderate';
                        
                        aqiCategory.textContent = category;
                    }
                    
                    // Update last updated time
                    const aqiTime = document.getElementById('aqi-time');
                    if (aqiTime && primaryData.DateObserved && primaryData.HourObserved >= 0) {
                        const dateStr = primaryData.DateObserved;
                        const hour = String(primaryData.HourObserved).padStart(2, '0');
                        const observationDate = new Date(`${dateStr} ${hour}:00:00 PST`);
                        
                        aqiTime.textContent = observationDate.toLocaleTimeString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit'
                        }) + ' PST';
                    }
                    
                } else {
                    throw new Error('No air quality data available');
                }
                
            } catch (error) {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const errorText = isMobile ? 'Mobile Network Issue' : 'Unavailable';
                
                const aqiIndex = document.getElementById('aqi-index');
                const aqiPollutant = document.getElementById('aqi-pollutant');
                const aqiCategory = document.getElementById('aqi-category');
                const aqiTime = document.getElementById('aqi-time');
                
                if (aqiIndex) aqiIndex.textContent = errorText;
                if (aqiPollutant) aqiPollutant.textContent = errorText;
                if (aqiCategory) aqiCategory.textContent = errorText;
                if (aqiTime) aqiTime.textContent = errorText;
            }
        }

        // Update all real-time data with comprehensive error handling
        async function updateAllRealTime() {
            try {
            console.log('UPDATE DEBUG: Starting updateAllRealTime()');
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log('UPDATE DEBUG: Mobile device detected:', isMobile);
            
            updateTime();
            
            // For mobile, load APIs one at a time to make debugging readable
            if (isMobile) {
                console.log('UPDATE DEBUG: Loading mobile APIs sequentially for better debugging');
                
                console.log('MOBILE SEQUENCE: 1/11 - Loading Weather...');
                await fetchRealWeatherData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 2/11 - Loading Astronomical...');
                await fetchRealAstronomicalData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 3/11 - Loading Tides...');
                await fetchRealTideData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 4/11 - Loading Sea Conditions...');
                await fetchRealSeaData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 5/11 - Loading Air Quality...');
                await fetchRealAirQuality().catch(() => {});
                
                console.log('MOBILE DEBUG: Completed sequential loading - check results above');
            } else {
                // Desktop - load all APIs simultaneously
                console.log('UPDATE DEBUG: Starting Promise.allSettled for all APIs');
                const results = await Promise.allSettled([
                    fetchRealWeatherData(),
                    fetchWeatherForecast(),
                    fetchRealTideData(), 
                    fetchRealSeaData(),
                    fetchCurrentsData(),
                    fetchEarthquakeData(),
                    fetchTsunamiAlerts(),
                    fetchRealAstronomicalData(),
                    fetchRealNotices(),
                    fetchRealAirQuality(),
                    fetchRealWeatherAlerts()
                ]);
                
                console.log('UPDATE DEBUG: API results summary:');
                const apiNames = ['Weather', 'Forecast', 'Tides', 'Sea', 'Currents', 'Earthquake', 'Tsunami', 'Astronomical', 'Notices', 'AirQuality', 'WeatherAlerts'];
                results.forEach((result, index) => {
                    console.log(`UPDATE DEBUG: ${apiNames[index]} - ${result.status}`, result.status === 'rejected' ? result.reason?.message : 'Success');
                });
            }
            
            } catch (error) {
                console.error('UPDATE CYCLE ERROR:', error);
            }
        }

        // ERROR DEBUGGING - Log all errors to console for troubleshooting
        window.addEventListener('error', function(e) {
            console.error('GLOBAL ERROR:', e.error, 'at', e.filename + ':' + e.lineno);
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('UNHANDLED PROMISE REJECTION:', e.reason);
        });
        
        // MOBILE DEBUGGING - Detect mobile and add specific debugging
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            console.log('MOBILE DEVICE DETECTED:', navigator.userAgent);
        }

        // Initialize the system with error handling
        try {
            console.log('INIT: Starting system initialization...');
            
            // Start real-time data updates immediately and then every 30 seconds
            setTimeout(updateAllRealTime, 1000); // Start after 1 second
            setInterval(updateAllRealTime, 30000); // Every 30 seconds
            
            // Update time every second
            setInterval(updateTime, 1000);
            
            console.log('INIT: System initialization complete');
        } catch (error) {
            console.error('INIT ERROR:', error);
        }
    </script>

    <!-- Mobile Debug Panel (only visible on mobile) -->
    <div id="mobile-debug-panel" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.95); color: #00ff00; font-family: monospace; font-size: 10px; padding: 10px; max-height: 250px; overflow-y: auto; border-top: 2px solid #00ff00; z-index: 9999;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 5px;">
            <span style="color: #ff6600; font-weight: bold;">üì± MOBILE DEBUG CONSOLE</span>
            <div style="display: flex; gap: 5px;">
                <button id="pause-debug-btn" onclick="toggleDebugPause()" style="background: #ff6600; color: #fff; border: 1px solid #666; padding: 2px 8px; font-size: 10px; cursor: pointer;">PAUSE</button>
                <button onclick="clearDebugOutput()" style="background: #666; color: #fff; border: 1px solid #666; padding: 2px 8px; font-size: 10px; cursor: pointer;">CLEAR</button>
                <button onclick="toggleDebugPanel()" style="background: #333; color: #fff; border: 1px solid #666; padding: 2px 8px; font-size: 10px; cursor: pointer;">HIDE</button>
            </div>
        </div>
        <div id="debug-output" style="white-space: pre-wrap; line-height: 1.2;"></div>
    </div>

    <!-- Debug Toggle Button -->
    <div id="debug-toggle" style="display: none; position: fixed; top: 10px; right: 10px; background: rgba(255,102,0,0.8); color: white; padding: 8px 12px; border-radius: 20px; font-size: 12px; font-weight: bold; cursor: pointer; z-index: 10000; border: 2px solid #ff6600;" onclick="toggleDebugPanel()">
        üêõ DEBUG
    </div>

    <script>
        // Mobile debug logging system
        let debugMessages = [];
        const maxDebugMessages = 50;
        let debugPaused = false;

        // Override console.log for mobile debugging
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;

        function addDebugMessage(type, ...args) {
            // Don't add messages when paused
            if (debugPaused) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
            
            debugMessages.push({
                time: timestamp,
                type: type,
                message: message
            });

            // Keep only the last maxDebugMessages
            if (debugMessages.length > maxDebugMessages) {
                debugMessages = debugMessages.slice(-maxDebugMessages);
            }

            updateDebugDisplay();
        }

        // Override console methods for mobile debugging
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            addDebugMessage('LOG', ...args);
        };

        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            addDebugMessage('ERR', ...args);
        };

        console.warn = function(...args) {
            originalConsoleWarn.apply(console, args);
            addDebugMessage('WARN', ...args);
        };

        function updateDebugDisplay() {
            const debugOutput = document.getElementById('debug-output');
            if (debugOutput) {
                const displayMessages = debugMessages.slice(-20); // Show last 20 messages
                debugOutput.textContent = displayMessages.map(msg => 
                    `[${msg.time}] ${msg.type}: ${msg.message}`
                ).join('\n');
                
                // Auto-scroll to bottom
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
        }

        function toggleDebugPanel() {
            const panel = document.getElementById('mobile-debug-panel');
            const toggle = document.getElementById('debug-toggle');
            
            if (panel.style.display === 'none' || !panel.style.display) {
                panel.style.display = 'block';
                toggle.style.display = 'none';
            } else {
                panel.style.display = 'none';
                toggle.style.display = 'block';
            }
        }

        function toggleDebugPause() {
            debugPaused = !debugPaused;
            const pauseBtn = document.getElementById('pause-debug-btn');
            if (debugPaused) {
                pauseBtn.textContent = 'RESUME';
                pauseBtn.style.background = '#10b981';
                console.log('DEBUG PAUSED - Click RESUME to continue logging');
            } else {
                pauseBtn.textContent = 'PAUSE';
                pauseBtn.style.background = '#ff6600';
                console.log('DEBUG RESUMED - Logging will continue');
            }
        }

        function clearDebugOutput() {
            debugMessages = [];
            updateDebugDisplay();
            console.log('DEBUG CLEARED - Fresh start');
        }

        // Show debug controls only on mobile
        function initMobileDebug() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('debug-toggle').style.display = 'block';
                console.log('MOBILE DEBUG: Debug panel initialized for mobile device');
                console.log('MOBILE DEBUG: User Agent:', navigator.userAgent);
                console.log('MOBILE DEBUG: Location:', window.location.href);
            }
        }

        // Initialize debug panel
        document.addEventListener('DOMContentLoaded', function() {
            initMobileDebug();
        });
    </script>

</body>
</html>