<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>San Diego METOC - Maritime Operations Center</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            color: #f1f5f9;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1.5rem 0;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 12px;
            border: 1px solid #334155;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #60a5fa;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .header p {
            font-size: 1.125rem;
            color: #cbd5e1;
            font-weight: 300;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 23, 42, 0.9);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border: 1px solid #334155;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #cbd5e1;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #334155;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px rgba(0, 0, 0, 0.2);
        }

        .card-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #334155;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
        }

        .data-row:last-child {
            border-bottom: none;
        }

        .data-label {
            font-size: 0.875rem;
            color: #94a3b8;
            font-weight: 500;
        }

        .data-value {
            font-size: 1rem;
            font-weight: 600;
            color: #f1f5f9;
            text-align: right;
        }

        .highlight-update {
            background: linear-gradient(90deg, rgba(96, 165, 250, 0.2), transparent);
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .temp-display {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            margin: 1rem 0;
            color: #60a5fa;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .alert-item {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 1rem;
        }

        .alert-title {
            font-weight: 600;
            color: #fca5a5;
            margin-bottom: 0.5rem;
        }

        .alert-time {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 0.5rem;
        }

        .vessel-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            border: 1px solid #334155;
        }

        .vessel-name {
            font-weight: 600;
            color: #e2e8f0;
        }

        .vessel-type {
            font-size: 0.75rem;
            color: #94a3b8;
            text-transform: uppercase;
        }

        .vessel-status {
            font-size: 0.875rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .vessel-status.active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .vessel-status.anchored {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .responsive-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
        }

        .update-time {
            text-align: center;
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 2rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 8px;
        }

        .forecast-container {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #334155 transparent;
        }

        .forecast-container::-webkit-scrollbar {
            width: 4px;
        }

        .forecast-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .forecast-container::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }
            
            .container {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header Section -->
        <div class="header">
            <h1>üõ°Ô∏è San Diego METOC</h1>
            <p>Maritime Operations Center - Real-Time Operational Data</p>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-dot"></div>
                <span>System Status: <span id="systemStatus">Operational</span></span>
            </div>
            <div class="status-item">
                <span>‚è∞ Current Time: <span id="currentTime">Loading...</span></span>
            </div>
            <div class="status-item">
                <span>üì° Data Sources: <span id="activeConnections">7 Active</span></span>
            </div>
        </div>

        <!-- Main Dashboard Grid -->
        <div class="grid">
            <!-- Current Weather -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üå§Ô∏è Current Weather</div>
                </div>
                <div class="temp-display" id="main-temp">Loading...</div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Temperature</span>
                        <span class="data-value" id="temp-display">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Wind Speed</span>
                        <span class="data-value" id="wind-speed">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Wind Direction</span>
                        <span class="data-value" id="wind-direction">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Humidity</span>
                        <span class="data-value" id="humidity">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Pressure</span>
                        <span class="data-value" id="pressure">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Visibility</span>
                        <span class="data-value" id="visibility">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Weather Forecast -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üìÖ 6-Hour Forecast</div>
                </div>
                <div class="forecast-container" id="weather-forecast">
                    <div class="data-value">Loading forecast...</div>
                </div>
            </div>

            <!-- Tide Information -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåä Tide Information</div>
                    <div class="card-subtitle">NOAA Station 9410170 - San Diego Bay</div>
                </div>
                <div class="card-content">
                    <!-- Current Tide Level with Visual Bar -->
                    <div style="margin-bottom: 1rem;">
                        <div class="data-row">
                            <span class="data-label">Current Tide</span>
                            <span class="data-value" id="current-tide">Loading...</span>
                        </div>
                        <!-- Visual Tide Level Bar -->
                        <div style="margin-top: 0.5rem; background: rgba(148, 163, 184, 0.2); height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
                            <div id="tide-level-bar" style="height: 100%; background: linear-gradient(90deg, #3b82f6, #06b6d4); width: 50%; border-radius: 10px; transition: width 0.5s ease;"></div>
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.7rem; color: #1e293b; font-weight: bold; text-shadow: 0 0 2px rgba(255,255,255,0.8);" id="tide-level-text">--</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #94a3b8; margin-top: 0.25rem;">
                            <span>Low</span>
                            <span id="tide-direction" style="font-weight: 500;">Loading...</span>
                            <span>High</span>
                        </div>
                    </div>
                    
                    <!-- Tide Times -->
                    <div style="border-top: 1px solid rgba(148, 163, 184, 0.2); padding-top: 0.75rem;">
                        <div class="data-row">
                            <span class="data-label">Next High</span>
                            <span class="data-value" id="high-tide">Loading...</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">Next Low</span>
                            <span class="data-value" id="low-tide">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Sea Conditions -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåä Sea Conditions</div>
                    <div class="card-subtitle" id="buoy-source">NOAA Buoy Data</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Significant Wave Height</span>
                        <span class="data-value" id="wave-height">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Dominant Wave Period</span>
                        <span class="data-value" id="wave-period">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Primary Swell Height</span>
                        <span class="data-value" id="swell-height">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Primary Swell Period</span>
                        <span class="data-value" id="swell-period">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Swell Direction</span>
                        <span class="data-value" id="swell-direction">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Sea Surface Temp</span>
                        <span class="data-value" id="water-temp">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Astronomical Data -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåô Astronomical</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Twilight Begin</span>
                        <span class="data-value" id="twilight-begin">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Twilight End</span>
                        <span class="data-value" id="twilight-end">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Moon Phase</span>
                        <span class="data-value" id="moon-phase">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Moon Illumination</span>
                        <span class="data-value" id="moon-illumination">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Visibility</span>
                        <span class="data-value" id="visibility-conditions">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Surface Currents -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåä Surface Currents</div>
                    <div class="card-subtitle">NOAA CO-OPS San Diego Bay</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Current Speed</span>
                        <span class="data-value" id="current-speed">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Current Direction</span>
                        <span class="data-value" id="current-direction">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Tidal Current</span>
                        <span class="data-value" id="tidal-current">Loading...</span>
                    </div>
                </div>
            </div>

            <!-- Seismic & Tsunami Monitoring -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üåç Seismic & Tsunami Monitoring</div>
                    <div class="card-subtitle">USGS Earthquakes + NOAA Tsunami Alerts</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">Tsunami Status</span>
                        <span class="data-value" id="tsunami-status">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Last Alert Update</span>
                        <span class="data-value" id="tsunami-time">Loading...</span>
                    </div>
                    <div style="border-top: 1px solid rgba(148, 163, 184, 0.2); margin: 0.75rem 0; padding-top: 0.75rem;">
                        <div style="font-size: 0.875rem; color: #cbd5e1; margin-bottom: 0.5rem; font-weight: 500;">Recent Earthquakes (48hrs, 100km)</div>
                        <div id="earthquake-container">
                            <div class="data-value">Loading earthquake data...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Air Quality -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üå´Ô∏è Air Quality</div>
                    <div class="card-subtitle">EPA AirNow San Diego</div>
                </div>
                <div class="card-content">
                    <div class="data-row">
                        <span class="data-label">AQI Index</span>
                        <span class="data-value" id="aqi-index">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Primary Pollutant</span>
                        <span class="data-value" id="aqi-pollutant">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Health Category</span>
                        <span class="data-value" id="aqi-category">Loading...</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Last Updated</span>
                        <span class="data-value" id="aqi-time">Loading...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lower Grid for Additional Information -->
        <div class="responsive-grid">
            <!-- Local Notices -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üìã Local Notices</div>
                    <div class="card-subtitle">USCG Sector San Diego Maritime Safety</div>
                </div>
                <div style="max-height: 400px; overflow-y: auto; margin-bottom: 0.75rem;" id="notices-container">
                    <div class="data-value" style="text-align: center; padding: 1rem; color: #94a3b8;">
                        <div class="loading-spinner" style="margin: 0 auto 0.5rem; width: 20px; height: 20px; border: 2px solid rgba(148, 163, 184, 0.3); border-top: 2px solid #60a5fa; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        Loading maritime notices...
                    </div>
                </div>
                
                <!-- Enhanced Footer -->
                <div style="background: rgba(15, 23, 42, 0.6); padding: 0.75rem; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.2);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <div style="font-size: 0.8rem; font-weight: 500; color: #cbd5e1;">üìÑ Official Resources</div>
                        <div style="font-size: 0.7rem; color: #94a3b8;">Updated Live</div>
                    </div>
                    <div style="display: grid; gap: 0.5rem;">
                        <a href="https://navcen.uscg.gov/local-notices-to-mariners?district=11+0&subdistrict=n" target="_blank" 
                           style="color: #60a5fa; text-decoration: none; font-size: 0.75rem; padding: 0.4rem 0.6rem; background: rgba(96, 165, 250, 0.1); border-radius: 4px; border: 1px solid rgba(96, 165, 250, 0.3); display: block; text-align: center; transition: all 0.2s;">
                            üìã Weekly LNM District 11 - Current Edition
                        </a>
                        <div style="font-size: 0.65rem; color: #94a3b8; text-align: center; margin-top: 0.25rem;">
                            Data refreshed every 30 seconds from official USCG feeds
                        </div>
                    </div>
                </div>
            </div>


            <!-- Active Alerts -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">‚ö†Ô∏è Active Alerts</div>
                </div>
                <div class="alert-item" style="margin-bottom: 0.5rem;" id="alerts-container">
                    <div class="alert-title" id="alert-title">Loading alerts...</div>
                    <div id="alert-desc" style="font-size: 0.875rem;">Checking NOAA Weather Service for active marine warnings</div>
                    <div class="alert-time" id="alert-time">Updating...</div>
                </div>
            </div>
        </div>

        <!-- Update Time -->
        <div class="update-time">
            Last Updated: <span id="lastUpdate"></span>
        </div>
    </div>

    <script>

        // Update current time in PST timezone
        function updateTime() {
            var now = new Date();
            var pstTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
            
            var hours = pstTime.getHours();
            var minutes = pstTime.getMinutes();
            var seconds = pstTime.getSeconds();
            
            var timeStr = (hours < 10 ? '0' : '') + hours + ':' + 
                         (minutes < 10 ? '0' : '') + minutes + ':' +
                         (seconds < 10 ? '0' : '') + seconds + ' PST';
            
            document.getElementById('currentTime').textContent = timeStr;
            document.getElementById('lastUpdate').textContent = pstTime.toLocaleString('en-US', {
                timeZone: 'America/Los_Angeles',
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            }) + ' PST';
        }

        // Reliable 24-hour time formatter for NOAA times
        function formatTime24Hour(dateString) {
            try {
                // NOAA API returns times in various formats, ensure 24-hour Pacific time
                const date = new Date(dateString);
                
                // Force 24-hour format using Intl.DateTimeFormat for Pacific timezone
                const formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'America/Los_Angeles',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                
                return formatter.format(date);
            } catch (error) {
                // Fallback if date parsing fails
                return 'Invalid Time';
            }
        }

        // Helper function to update elements with null checks
        function updateElement(id, value, color) {
            try {
                var el = document.getElementById(id);
                if (el) {
                    el.textContent = value;
                    if (color) el.style.color = color;
                    el.classList.add('highlight-update');
                    setTimeout(function() {
                        if (el && el.classList) {
                            el.classList.remove('highlight-update');
                        }
                    }, 2000);
                }
            } catch (error) {
                console.error('DOM UPDATE ERROR for', id, ':', error);
            }
        }

        // Clean fetch function with simple mobile handling
        async function fetchWithTimeout(url, timeout = 30000) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Mobile direct connection - simple approach
            if (isMobile && typeof url === 'object' && url.mobileDirect) {
                console.log('MOBILE: Direct connection to', url.original?.substring(0, 60));
                
                try {
                    const response = await fetch(url.original, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json, text/plain, */*'
                        }
                    });
                    
                    if (response.ok) {
                        console.log('MOBILE: Success');
                        return response;
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                } catch (error) {
                    console.log('MOBILE: Failed -', error.message);
                    throw new Error('Mobile CORS blocked or network issue');
                }
            }
            
            // Desktop or single URL fallback to original method
            const controller = new AbortController();
            const finalTimeout = timeout;
            const timeoutId = setTimeout(() => controller.abort(), finalTimeout);
            
            try {
                const response = await fetch(typeof url === 'object' ? url.primary : url, {
                    signal: controller.signal,
                    headers: {
                        'User-Agent': 'METOC-Dashboard/1.0'
                    }
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Request timeout after ' + finalTimeout + 'ms');
                }
                throw error;
            }
        }

        // Fetch real weather data from NOAA
        async function fetchRealWeatherData() {
            try {
                
                const weatherUrl = getMobileFallbackUrls('https://api.weather.gov/stations/KSAN/observations/latest');
                const response = await fetchWithTimeout(weatherUrl, 15000);
                
                if (!response.ok) throw new Error('Weather API unavailable');
                
                const data = await response.json();
                const props = data.properties;
                
                if (props && props.temperature && props.temperature.value !== null) {
                    // Update with real NOAA data
                    const tempF = Math.round(props.temperature.value * 9/5 + 32);
                    updateElement('temp-display', tempF + '¬∞F');
                    updateElement('main-temp', tempF + '¬∞F');
                    
                    if (props.windSpeed && props.windSpeed.value !== null) {
                        updateElement('wind-speed', Math.round(props.windSpeed.value * 2.237) + ' mph');
                    }
                    
                    if (props.windDirection && props.windDirection.value !== null) {
                        const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                        const index = Math.round(props.windDirection.value / 22.5) % 16;
                        const windDirText = directions[index] + ' (' + Math.round(props.windDirection.value) + '¬∞)';
                        updateElement('wind-direction', windDirText);
                    }
                    
                    if (props.relativeHumidity && props.relativeHumidity.value !== null) {
                        updateElement('humidity', Math.round(props.relativeHumidity.value) + '%');
                    }
                    
                    if (props.barometricPressure && props.barometricPressure.value !== null) {
                        updateElement('pressure', (props.barometricPressure.value / 3386.39).toFixed(2) + '"');
                    }
                    
                    if (props.visibility && props.visibility.value !== null) {
                        updateElement('visibility', Math.round(props.visibility.value / 1609.34) + ' mi');
                    }
                    
                    updateElement('temp-display', tempF + '¬∞F');
                }
                
                
            } catch (error) {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const errorText = isMobile ? 'Mobile Network Issue' : 'Offline';
                
                updateElement('temp-display', errorText);
                updateElement('wind-speed', 'N/A');
                updateElement('wind-direction', 'N/A');
                updateElement('humidity', 'N/A');
                updateElement('pressure', 'N/A');
                updateElement('visibility', 'N/A');
            }
        }

        // Fetch weather forecast
        async function fetchWeatherForecast() {
            try {
                console.log('WEATHER FORECAST: Starting (working: weather/tides/astro, testing: forecast endpoint)');
                
                const forecastUrl = getMobileFallbackUrls('https://api.weather.gov/gridpoints/SGX/64,16/forecast/hourly');
                console.log('WEATHER FORECAST: Trying same domain as working weather (api.weather.gov) but different endpoint /gridpoints/SGX/64,16/forecast/hourly');
                
                const response = await fetchWithTimeout(forecastUrl);
                
                if (!response.ok) throw new Error('Forecast API unavailable');
                
                const data = await response.json();
                console.log('WEATHER FORECAST DEBUG: Response data structure:', Object.keys(data));
                console.log('WEATHER FORECAST DEBUG: Properties keys:', data.properties ? Object.keys(data.properties) : 'No properties');
                
                const forecast = data.properties.periods;
                
                if (forecast && forecast.length > 0) {
                    // Update forecast display
                    let forecastHTML = '';
                    
                    // Show next 6 hours for brevity
                    for (let i = 0; i < Math.min(6, forecast.length); i++) {
                        const period = forecast[i];
                        const time = new Date(period.startTime);
                        const displayTime = time.toLocaleTimeString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        
                        forecastHTML += `
                            <div class="forecast-item" style="display: flex; align-items: center; margin: 0.5rem 0; padding: 0.5rem; background: rgba(15, 23, 42, 0.3); border-radius: 4px;">
                                <div style="font-weight: 600; width: 60px;">${displayTime}</div>
                                <div style="flex: 1; margin-left: 1rem;">${period.shortForecast}</div>
                                <div style="font-weight: 600; color: #60a5fa;">${period.temperature}¬∞${period.temperatureUnit}</div>
                            </div>
                        `;
                    }
                    
                    const forecastEl = document.getElementById('weather-forecast');
                    if (forecastEl) {
                        try {
                            forecastEl.innerHTML = forecastHTML;
                        } catch (error) {
                            // Handle forecast display error
                        }
                    }
                }
                
                
            } catch (error) {
                console.log('WEATHER FORECAST: Failed with error:', error.message);
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log('WEATHER FORECAST: Mobile device:', isMobile, 'Error type analysis...');
                
                updateElement('weather-forecast', 'Forecast unavailable');
            }
        }

        // Update visual tide bar display
        function updateTideBar(currentLevel, predictions) {
            const tideBar = document.getElementById('tide-level-bar');
            const tideText = document.getElementById('tide-level-text');
            
            if (!tideBar || !tideText || !predictions) return;
            
            // Find the min and max tide levels from predictions
            let minTide = Infinity;
            let maxTide = -Infinity;
            
            for (let pred of predictions) {
                const level = parseFloat(pred.v);
                if (level < minTide) minTide = level;
                if (level > maxTide) maxTide = level;
            }
            
            // Calculate percentage for current level
            const range = maxTide - minTide;
            const percentage = range > 0 ? ((currentLevel - minTide) / range) * 100 : 50;
            const clampedPercentage = Math.max(5, Math.min(95, percentage));
            
            // Update bar width and color based on tide level
            tideBar.style.width = clampedPercentage + '%';
            tideText.textContent = currentLevel.toFixed(1) + 'ft';
            
            // Color coding based on tide level
            if (percentage < 25) {
                tideBar.style.background = 'linear-gradient(90deg, #dc2626, #ef4444)'; // Red for very low
            } else if (percentage < 50) {
                tideBar.style.background = 'linear-gradient(90deg, #ea580c, #f97316)'; // Orange for low
            } else if (percentage < 75) {
                tideBar.style.background = 'linear-gradient(90deg, #3b82f6, #06b6d4)'; // Blue for medium
            } else {
                tideBar.style.background = 'linear-gradient(90deg, #059669, #10b981)'; // Green for high
            }
        }

        // Fetch real tide data from NOAA
        async function fetchRealTideData() {
            try {
                console.log('TIDES DEBUG: Starting fetch');
                
                // Get current Pacific time for date range
                const now = new Date();
                const pstNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
                const today = pstNow.toISOString().split('T')[0].replace(/-/g, '');
                const tomorrow = new Date(pstNow.getTime() + 24*60*60*1000).toISOString().split('T')[0].replace(/-/g, '');
                console.log('TIDES DEBUG: Date range:', today, 'to', tomorrow);
                
                // Fetch both predictions and current water level  
                const predUrl = getMobileFallbackUrls(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${today}&end_date=${tomorrow}&station=9410170&product=predictions&datum=mllw&units=english&time_zone=lst_ldt&format=json&interval=hilo`);
                console.log('TIDES DEBUG: Predictions URL generated:', predUrl);
                const currentUrl = getMobileFallbackUrls(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?date=latest&station=9410170&product=water_level&datum=mllw&units=english&time_zone=lst_ldt&format=json`);
                
                console.log('TIDE URLS:', { predUrl, currentUrl });
                
                
                const [predResponse, currentResponse] = await Promise.allSettled([
                    fetchWithTimeout(predUrl),
                    fetchWithTimeout(currentUrl)
                ]);
                
                console.log('TIDES DEBUG: Response statuses:', {
                    pred: predResponse.status,
                    current: currentResponse.status
                });
                
                if (predResponse.status !== 'fulfilled') {
                    console.error('TIDES DEBUG: Predictions failed:', predResponse.reason);
                    throw new Error('Tide predictions API unavailable');
                }
                
                if (!predResponse.value.ok) {
                    console.error('TIDES DEBUG: Predictions HTTP error:', predResponse.value.status);
                    throw new Error('Tide predictions API unavailable');
                }
                
                const predText = await predResponse.value.text();
                console.log('TIDES DEBUG: Predictions raw response:', predText.substring(0, 300));
                
                let data;
                try {
                    data = JSON.parse(predText);
                    console.log('TIDES DEBUG: Predictions parsed data:', data);
                } catch (parseError) {
                    console.error('TIDES DEBUG: Predictions JSON parse failed:', parseError);
                    throw new Error('Failed to parse tide predictions JSON');
                }
                
                const predictions = data.predictions;
                console.log('TIDES DEBUG: Predictions array length:', predictions?.length);
                
                // Get current water level
                let currentLevel = null;
                if (currentResponse.status === 'fulfilled' && currentResponse.value.ok) {
                    const currentData = await currentResponse.value.json();
                    if (currentData.data && currentData.data.length > 0) {
                        currentLevel = parseFloat(currentData.data[0].v);
                    }
                }
                
                if (predictions && predictions.length > 0) {
                    // Use PST timezone for accurate comparison
                    const now = new Date();
                    const pstNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
                    
                    // Find next high and low tides in PST
                    let nextHigh = null;
                    let nextLow = null;
                    
                    for (let pred of predictions) {
                        // NOAA returns times in PST already due to time_zone=lst_ldt parameter
                        const predTime = new Date(pred.t);
                        if (predTime > pstNow) {
                            if (pred.type === 'H' && !nextHigh) nextHigh = pred;
                            if (pred.type === 'L' && !nextLow) nextLow = pred;
                            if (nextHigh && nextLow) break;
                        }
                    }
                    
                    // Use real current water level if available, otherwise use closest prediction
                    if (currentLevel !== null) {
                        updateElement('current-tide', currentLevel.toFixed(1) + ' ft');
                        updateTideBar(currentLevel, predictions);
                    } else {
                        // Fallback to closest prediction using PST time
                        let closestPred = null;
                        let minTimeDiff = Infinity;
                        
                        for (let pred of predictions) {
                            const predTime = new Date(pred.t);
                            const timeDiff = Math.abs(predTime - pstNow);
                            
                            if (timeDiff < minTimeDiff) {
                                minTimeDiff = timeDiff;
                                closestPred = pred;
                            }
                        }
                        
                        if (closestPred) {
                            const level = parseFloat(closestPred.v);
                            updateElement('current-tide', level.toFixed(1) + ' ft');
                            updateTideBar(level, predictions);
                        }
                    }
                    
                    if (nextHigh) {
                        // COMPREHENSIVE 24-hour time parsing
                        const timeStr = nextHigh.t;
                        let displayTime = "N/A";
                        
                        try {
                            // Create date and extract time with guaranteed 24-hour format
                            const date = new Date(timeStr);
                            
                            // Manual 24-hour extraction - guaranteed to work
                            let hours = date.getHours();
                            let minutes = date.getMinutes();
                            
                            // Handle timezone offset if needed (Pacific is UTC-8 or UTC-7)
                            // If date seems wrong, try adjusting
                            if (hours === 0 && minutes === 0) {
                                // Try parsing as ISO string with timezone
                                const isoDate = new Date(timeStr + (timeStr.includes('T') ? '' : 'T00:00:00-08:00'));
                                hours = isoDate.getHours();
                                minutes = isoDate.getMinutes();
                            }
                            
                            // Format to 24-hour HH:MM
                            const h24 = hours.toString().padStart(2, '0');
                            const m24 = minutes.toString().padStart(2, '0');
                            displayTime = `${h24}:${m24}`;
                            
                        } catch (error) {
                            // Last resort: try string parsing
                            if (typeof timeStr === 'string' && timeStr.includes(' ')) {
                                const parts = timeStr.split(' ');
                                if (parts.length >= 2) {
                                    displayTime = parts[1].substring(0, 5);
                                }
                            }
                        }
                        
                        updateElement('high-tide', displayTime + ' PST - ' + parseFloat(nextHigh.v).toFixed(1) + ' ft');
                    }
                    
                    if (nextLow) {
                        // COMPREHENSIVE 24-hour time parsing
                        const timeStr = nextLow.t;
                        let displayTime = "N/A";
                        
                        try {
                            // Create date and extract time with guaranteed 24-hour format
                            const date = new Date(timeStr);
                            
                            // Manual 24-hour extraction - guaranteed to work
                            let hours = date.getHours();
                            let minutes = date.getMinutes();
                            
                            // Handle timezone offset if needed (Pacific is UTC-8 or UTC-7)
                            // If date seems wrong, try adjusting
                            if (hours === 0 && minutes === 0) {
                                // Try parsing as ISO string with timezone
                                const isoDate = new Date(timeStr + (timeStr.includes('T') ? '' : 'T00:00:00-08:00'));
                                hours = isoDate.getHours();
                                minutes = isoDate.getMinutes();
                            }
                            
                            // Format to 24-hour HH:MM
                            const h24 = hours.toString().padStart(2, '0');
                            const m24 = minutes.toString().padStart(2, '0');
                            displayTime = `${h24}:${m24}`;
                            
                        } catch (error) {
                            // Last resort: try string parsing
                            if (typeof timeStr === 'string' && timeStr.includes(' ')) {
                                const parts = timeStr.split(' ');
                                if (parts.length >= 2) {
                                    displayTime = parts[1].substring(0, 5);
                                }
                            }
                        }
                        
                        updateElement('low-tide', displayTime + ' PST - ' + parseFloat(nextLow.v).toFixed(1) + ' ft');
                    }
                    
                    // Determine if tide is rising or falling
                    if (nextHigh && nextLow) {
                        const highTime = new Date(nextHigh.t);
                        const lowTime = new Date(nextLow.t);
                        const isRising = highTime < lowTime;
                        updateElement('tide-direction', isRising ? 'Rising ‚¨ÜÔ∏è' : 'Falling ‚¨áÔ∏è');
                    }
                }
                
                
            } catch (error) {
                updateElement('current-tide', 'Offline');
                updateElement('high-tide', 'N/A');
                updateElement('low-tide', 'N/A');
            }
        }

        // CORS proxy helper function
        function getCorsProxyUrl(originalUrl) {
            // Check if we need CORS proxy (GitHub Pages or other hosted environments)
            const needsCorsProxy = window.location.hostname.includes('github.io') || 
                                 (window.location.protocol === 'https:' && window.location.hostname !== 'localhost');
            
            if (needsCorsProxy) {
                // Desktop: Use API-specific proxies - return string for backward compatibility
                if (originalUrl.includes('tidesandcurrents.noaa.gov') || originalUrl.includes('weather.gov')) {
                    return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(originalUrl);
                }
                
                // Use codetabs for other APIs on desktop
                return 'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(originalUrl);
            }
            
            // Use direct URL for local development
            return originalUrl;
        }

        // Clean mobile strategy - simple and reliable
        function getMobileFallbackUrls(originalUrl) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile && (window.location.hostname.includes('github.io') || 
                           (window.location.protocol === 'https:' && window.location.hostname !== 'localhost'))) {
                
                // Simple mobile approach: try direct connection only
                // If it fails, show honest CORS blocked status
                return {
                    url: originalUrl,
                    original: originalUrl,
                    isMobile: true,
                    mobileDirect: true
                };
            }
            
            // Desktop - maintain full original proxy system
            return getCorsProxyUrl(originalUrl);
        }


        // Parse NOAA buoy text data for real oceanographic measurements
        function parseBuoyData(buoyText) {
            console.log('SEA CONDITIONS PARSER: Starting NOAA buoy data parsing');
            
            try {
                const lines = buoyText.split('\n');
                console.log('SEA CONDITIONS PARSER: Found', lines.length, 'lines of data');
                
                // Find the header line to understand data format
                let headerLine = '';
                let dataLine = '';
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].startsWith('#YY')) {
                        headerLine = lines[i];
                        // Find first data line (not starting with #)
                        for (let j = i + 1; j < lines.length; j++) {
                            if (!lines[j].startsWith('#') && lines[j].trim().length > 0) {
                                dataLine = lines[j];
                                break;
                            }
                        }
                        break;
                    }
                }
                
                console.log('SEA CONDITIONS PARSER: Header:', headerLine);
                console.log('SEA CONDITIONS PARSER: Data line:', dataLine);
                
                if (!dataLine) {
                    throw new Error('No data lines found');
                }
                
                // Parse data columns (space-separated)
                const data = dataLine.trim().split(/\s+/);
                console.log('SEA CONDITIONS PARSER: Data columns:', data.length, 'values');
                
                // NOAA buoy format: YY MM DD hh mm WDIR WSPD GST WVHT DPD APD MWD PRES ATMP WTMP DEWP VIS
                // Indices: 0  1  2  3  4  5    6    7   8    9   10  11  12   13   14   15   16
                
                const buoyData = {};
                
                if (data.length > 8 && data[8] !== 'MM') {
                    buoyData.waveHeight = parseFloat(data[8]); // WVHT in meters
                }
                
                if (data.length > 9 && data[9] !== 'MM') {
                    buoyData.dominantPeriod = parseFloat(data[9]); // DPD in seconds
                }
                
                if (data.length > 10 && data[10] !== 'MM') {
                    buoyData.averagePeriod = parseFloat(data[10]); // APD in seconds
                }
                
                if (data.length > 11 && data[11] !== 'MM') {
                    buoyData.meanWaveDirection = parseFloat(data[11]); // MWD in degrees
                }
                
                if (data.length > 14 && data[14] !== 'MM') {
                    buoyData.waterTemp = parseFloat(data[14]); // WTMP in Celsius
                }
                
                console.log('SEA CONDITIONS PARSER: Parsed buoy data:', buoyData);
                return buoyData;
                
            } catch (error) {
                console.log('SEA CONDITIONS PARSER: Failed to parse buoy text:', error.message);
                return null;
            }
        }

        // Update sea conditions display with real buoy data
        function updateSeaConditionsDisplay(buoyData) {
            console.log('SEA CONDITIONS DISPLAY: Updating with real buoy data:', buoyData);
            
            // Wave Height (convert from meters to feet)
            if (buoyData.waveHeight && !isNaN(buoyData.waveHeight)) {
                const waveHeightFt = (buoyData.waveHeight * 3.28084).toFixed(1);
                updateElement('wave-height', waveHeightFt + ' ft');
                console.log('SEA CONDITIONS DISPLAY: Wave height:', waveHeightFt, 'ft');
            } else {
                updateElement('wave-height', 'No Data');
            }
            
            // Wave Period (dominant period)
            if (buoyData.dominantPeriod && !isNaN(buoyData.dominantPeriod)) {
                updateElement('wave-period', buoyData.dominantPeriod.toFixed(0) + ' sec');
                console.log('SEA CONDITIONS DISPLAY: Wave period:', buoyData.dominantPeriod, 'sec');
            } else if (buoyData.averagePeriod && !isNaN(buoyData.averagePeriod)) {
                updateElement('wave-period', buoyData.averagePeriod.toFixed(0) + ' sec');
                console.log('SEA CONDITIONS DISPLAY: Average period:', buoyData.averagePeriod, 'sec');
            } else {
                updateElement('wave-period', 'No Data');
            }
            
            // Primary Swell (use wave data as swell approximation)
            if (buoyData.waveHeight && !isNaN(buoyData.waveHeight)) {
                const swellHeightFt = (buoyData.waveHeight * 0.8 * 3.28084).toFixed(1); // Estimate swell as 80% of wave height
                updateElement('swell-height', swellHeightFt + ' ft');
                
                if (buoyData.dominantPeriod && !isNaN(buoyData.dominantPeriod)) {
                    updateElement('swell-period', buoyData.dominantPeriod.toFixed(0) + ' sec');
                }
                
                if (buoyData.meanWaveDirection && !isNaN(buoyData.meanWaveDirection)) {
                    const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                    const index = Math.round(buoyData.meanWaveDirection / 22.5) % 16;
                    updateElement('swell-direction', directions[index] + ' (' + Math.round(buoyData.meanWaveDirection) + '¬∞)');
                } else {
                    updateElement('swell-direction', 'Variable');
                }
            } else {
                updateElement('swell-height', 'No Data');
                updateElement('swell-period', 'No Data');
                updateElement('swell-direction', 'No Data');
            }
            
            // Water Temperature (convert from Celsius to Fahrenheit)
            if (buoyData.waterTemp && !isNaN(buoyData.waterTemp)) {
                const waterTempF = Math.round(buoyData.waterTemp * 9/5 + 32);
                updateElement('water-temp', waterTempF + '¬∞F');
                console.log('SEA CONDITIONS DISPLAY: Water temperature:', waterTempF, '¬∞F');
            } else {
                updateElement('water-temp', 'No Data');
            }
        }

        // Parse CDIP UC San Diego wave data
        function parseCdipData(cdipText) {
            console.log('SEA CONDITIONS CDIP PARSER: Starting CDIP data parsing');
            
            try {
                // Find San Diego area stations in CDIP data
                const lines = cdipText.split('\n');
                
                // Look for Point Loma South, Mission Bay West, or Imperial Beach
                let stationData = null;
                let stationName = '';
                
                for (const line of lines) {
                    if (line.includes('Point Loma South') || line.includes('Mission Bay West') || line.includes('Imperial Beach')) {
                        console.log('SEA CONDITIONS CDIP PARSER: Found San Diego station line:', line);
                        
                        // Parse the data line - format might be tab or space separated
                        const parts = line.split(/\s+/);
                        
                        // Try to find wave height, period, and temperature values
                        for (let i = 0; i < parts.length; i++) {
                            const value = parseFloat(parts[i]);
                            if (!isNaN(value)) {
                                if (!stationData) {
                                    stationData = {
                                        waveHeight: null,
                                        wavePeriod: null,
                                        waterTemp: null
                                    };
                                }
                                
                                // Heuristic: First reasonable value is wave height, second is period, third is temp
                                if (value > 0 && value < 10 && !stationData.waveHeight) {
                                    stationData.waveHeight = value; // meters
                                } else if (value > 5 && value < 25 && !stationData.wavePeriod) {
                                    stationData.wavePeriod = value; // seconds
                                } else if (value > 10 && value < 35 && !stationData.waterTemp) {
                                    stationData.waterTemp = value; // Celsius
                                }
                            }
                        }
                        
                        if (line.includes('Point Loma South')) stationName = 'CDIP Point Loma South';
                        else if (line.includes('Mission Bay West')) stationName = 'CDIP Mission Bay West';  
                        else if (line.includes('Imperial Beach')) stationName = 'CDIP Imperial Beach Nearshore';
                        
                        break;
                    }
                }
                
                if (stationData) {
                    stationData.stationName = stationName;
                    console.log('SEA CONDITIONS CDIP PARSER: Parsed data:', stationData);
                    return stationData;
                } else {
                    console.log('SEA CONDITIONS CDIP PARSER: No San Diego stations found');
                    return null;
                }
                
            } catch (error) {
                console.log('SEA CONDITIONS CDIP PARSER: Failed to parse CDIP text:', error.message);
                return null;
            }
        }

        // Update sea conditions display with CDIP data
        function updateSeaConditionsFromCdip(cdipData) {
            console.log('SEA CONDITIONS DISPLAY: Updating with CDIP data:', cdipData);
            
            // Wave Height (convert from meters to feet)
            if (cdipData.waveHeight && !isNaN(cdipData.waveHeight)) {
                const waveHeightFt = (cdipData.waveHeight * 3.28084).toFixed(1);
                updateElement('wave-height', waveHeightFt + ' ft');
                console.log('SEA CONDITIONS DISPLAY: CDIP wave height:', waveHeightFt, 'ft');
            } else {
                updateElement('wave-height', 'No Data');
            }
            
            // Wave Period
            if (cdipData.wavePeriod && !isNaN(cdipData.wavePeriod)) {
                updateElement('wave-period', cdipData.wavePeriod.toFixed(0) + ' sec');
                console.log('SEA CONDITIONS DISPLAY: CDIP wave period:', cdipData.wavePeriod, 'sec');
            } else {
                updateElement('wave-period', 'No Data');
            }
            
            // Primary Swell (estimate from wave data)
            if (cdipData.waveHeight && !isNaN(cdipData.waveHeight)) {
                const swellHeightFt = (cdipData.waveHeight * 0.75 * 3.28084).toFixed(1); // Swell ~75% of wave
                updateElement('swell-height', swellHeightFt + ' ft');
                
                if (cdipData.wavePeriod && !isNaN(cdipData.wavePeriod)) {
                    updateElement('swell-period', cdipData.wavePeriod.toFixed(0) + ' sec');
                }
                
                // Typical San Diego swell direction (SW)
                updateElement('swell-direction', 'SW (est)');
            } else {
                updateElement('swell-height', 'No Data');
                updateElement('swell-period', 'No Data');
                updateElement('swell-direction', 'No Data');
            }
            
            // Water Temperature (convert from Celsius to Fahrenheit)
            if (cdipData.waterTemp && !isNaN(cdipData.waterTemp)) {
                const waterTempF = Math.round(cdipData.waterTemp * 9/5 + 32);
                updateElement('water-temp', waterTempF + '¬∞F');
                console.log('SEA CONDITIONS DISPLAY: CDIP water temperature:', waterTempF, '¬∞F');
            } else {
                updateElement('water-temp', 'No Data');
            }
        }

        // Parse NOAA marine forecast text for wave data
        function parseMarineForecastText(marineText) {
            console.log('SEA CONDITIONS MARINE PARSER: Starting marine forecast parsing');
            
            try {
                // Look for wave height patterns like "3 to 4 ft" or "seas 3-4 ft"
                const waveHeightMatch = marineText.match(/(?:seas?\s+|wave\s+height\s+)(?:of\s+)?(\d+(?:\.\d+)?)\s*(?:to\s+|\-)?(\d+(?:\.\d+)?)\s*ft/i);
                
                let waveHeight = null;
                if (waveHeightMatch) {
                    const min = parseFloat(waveHeightMatch[1]);
                    const max = parseFloat(waveHeightMatch[2]) || min;
                    waveHeight = (min + max) / 2;
                    console.log('SEA CONDITIONS MARINE PARSER: Found wave height:', min, 'to', max, 'ft, average:', waveHeight);
                }
                
                // Look for wave period patterns like "W 3 ft at 12 seconds"
                const periodMatches = marineText.matchAll(/([NSEW]{1,3})\s+(\d+(?:\.\d+)?)\s*ft\s+at\s+(\d+(?:\.\d+)?)\s*seconds?/gi);
                const periods = [];
                
                for (const match of periodMatches) {
                    const direction = match[1];
                    const height = parseFloat(match[2]);
                    const period = parseFloat(match[3]);
                    periods.push({ direction, height, period });
                    console.log('SEA CONDITIONS MARINE PARSER: Found wave component:', direction, height, 'ft at', period, 'sec');
                }
                
                // Get dominant period (from largest wave component)
                let dominantPeriod = null;
                if (periods.length > 0) {
                    const largest = periods.reduce((prev, current) => (current.height > prev.height) ? current : prev);
                    dominantPeriod = largest.period;
                }
                
                // Look for water temperature (might not be in marine forecast)
                const tempMatch = marineText.match(/water\s+temperature\s+(?:around\s+|about\s+)?(\d+)\s*degrees?/i);
                let waterTemp = null;
                if (tempMatch) {
                    waterTemp = parseFloat(tempMatch[1]);
                }
                
                if (waveHeight || dominantPeriod || periods.length > 0) {
                    const result = {
                        waveHeight: waveHeight,
                        wavePeriod: dominantPeriod,
                        waterTemp: waterTemp,
                        waveComponents: periods
                    };
                    console.log('SEA CONDITIONS MARINE PARSER: Parsed forecast data:', result);
                    return result;
                } else {
                    console.log('SEA CONDITIONS MARINE PARSER: No recognizable wave data found');
                    return null;
                }
                
            } catch (error) {
                console.log('SEA CONDITIONS MARINE PARSER: Failed to parse marine forecast:', error.message);
                return null;
            }
        }

        // Update sea conditions display with marine forecast data
        function updateSeaConditionsFromMarineForecast(forecastData) {
            console.log('SEA CONDITIONS DISPLAY: Updating with marine forecast data:', forecastData);
            
            // Wave Height 
            if (forecastData.waveHeight && !isNaN(forecastData.waveHeight)) {
                updateElement('wave-height', forecastData.waveHeight.toFixed(1) + ' ft');
                console.log('SEA CONDITIONS DISPLAY: Wave height:', forecastData.waveHeight, 'ft');
            } else {
                updateElement('wave-height', 'No Data');
            }
            
            // Wave Period
            if (forecastData.wavePeriod && !isNaN(forecastData.wavePeriod)) {
                updateElement('wave-period', forecastData.wavePeriod.toFixed(0) + ' sec');
                console.log('SEA CONDITIONS DISPLAY: Wave period:', forecastData.wavePeriod, 'sec');
            } else {
                updateElement('wave-period', 'No Data');
            }
            
            // Primary Swell (use largest wave component)
            if (forecastData.waveComponents && forecastData.waveComponents.length > 0) {
                const primarySwell = forecastData.waveComponents[0]; // Usually first/largest component
                
                updateElement('swell-height', primarySwell.height.toFixed(1) + ' ft');
                updateElement('swell-period', primarySwell.period.toFixed(0) + ' sec');
                updateElement('swell-direction', primarySwell.direction);
                
                console.log('SEA CONDITIONS DISPLAY: Primary swell:', primarySwell.direction, primarySwell.height, 'ft at', primarySwell.period, 'sec');
            } else if (forecastData.waveHeight) {
                // Estimate swell from wave height
                const swellHeight = (forecastData.waveHeight * 0.8).toFixed(1);
                updateElement('swell-height', swellHeight + ' ft (est)');
                updateElement('swell-period', forecastData.wavePeriod ? forecastData.wavePeriod.toFixed(0) + ' sec' : 'N/A');
                updateElement('swell-direction', 'SW (est)');
            } else {
                updateElement('swell-height', 'No Data');
                updateElement('swell-period', 'No Data'); 
                updateElement('swell-direction', 'No Data');
            }
            
            // Water Temperature
            if (forecastData.waterTemp && !isNaN(forecastData.waterTemp)) {
                updateElement('water-temp', Math.round(forecastData.waterTemp) + '¬∞F');
                console.log('SEA CONDITIONS DISPLAY: Water temperature:', forecastData.waterTemp, '¬∞F');
            } else {
                updateElement('water-temp', 'No Data');
            }
        }

        // Update sea conditions display with working CO-OPS marine data
        function updateSeaConditionsFromMarine(marineData) {
            console.log('SEA CONDITIONS DISPLAY: Updating with CO-OPS marine data:', marineData);
            
            // Real Water Temperature (already in Fahrenheit from CO-OPS API)
            if (marineData.waterTemp && !isNaN(marineData.waterTemp)) {
                updateElement('water-temp', Math.round(marineData.waterTemp) + '¬∞F');
                console.log('SEA CONDITIONS DISPLAY: Real water temperature:', marineData.waterTemp, '¬∞F');
            } else {
                updateElement('water-temp', 'No Data');
            }
            
            // Estimate wave conditions from real wind data
            if (marineData.windSpeed && !isNaN(marineData.windSpeed)) {
                // Beaufort scale-based wave height estimation from real wind
                let waveHeightFt;
                if (marineData.windSpeed < 1) waveHeightFt = 0;
                else if (marineData.windSpeed < 4) waveHeightFt = 0.25;
                else if (marineData.windSpeed < 7) waveHeightFt = 0.5;
                else if (marineData.windSpeed < 11) waveHeightFt = 1.0;
                else if (marineData.windSpeed < 16) waveHeightFt = 2.0;
                else if (marineData.windSpeed < 22) waveHeightFt = 3.5;
                else if (marineData.windSpeed < 28) waveHeightFt = 6.0;
                else waveHeightFt = 9.0;
                
                updateElement('wave-height', waveHeightFt.toFixed(1) + ' ft (est)');
                
                // Wave period from wind speed (typical relationship)
                const periodSec = Math.max(4, Math.min(12, marineData.windSpeed * 0.4));
                updateElement('wave-period', periodSec.toFixed(0) + ' sec (est)');
                
                console.log('SEA CONDITIONS DISPLAY: Wave estimates - Height:', waveHeightFt, 'ft, Period:', periodSec, 'sec from', marineData.windSpeed, 'kt wind');
            } else {
                updateElement('wave-height', 'No Data');
                updateElement('wave-period', 'No Data');
            }
            
            // Estimate swell from wind (slightly smaller and longer period)
            if (marineData.windSpeed && !isNaN(marineData.windSpeed) && marineData.windDirection && !isNaN(marineData.windDirection)) {
                const swellHeightFt = Math.max(0.5, marineData.windSpeed * 0.1);
                const swellPeriod = Math.max(6, Math.min(14, marineData.windSpeed * 0.6));
                
                updateElement('swell-height', swellHeightFt.toFixed(1) + ' ft (est)');
                updateElement('swell-period', swellPeriod.toFixed(0) + ' sec (est)');
                
                // Wind direction as swell direction
                const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                const index = Math.round(marineData.windDirection / 22.5) % 16;
                updateElement('swell-direction', directions[index] + ' (' + Math.round(marineData.windDirection) + '¬∞)');
                
                console.log('SEA CONDITIONS DISPLAY: Swell estimates - Height:', swellHeightFt, 'ft, Period:', swellPeriod, 'sec, Direction:', directions[index]);
            } else {
                updateElement('swell-height', 'No Data');
                updateElement('swell-period', 'No Data');
                updateElement('swell-direction', 'No Data');
            }
        }

        // Fetch real sea conditions from NOAA Marine Forecast API
        async function fetchRealSeaData() {
            try {
                console.log('SEA CONDITIONS: Starting with NOAA Marine Forecast API - actual oceanographic data');
                
                // FINAL APPROACH: Use working NOAA marine forecast from forecast.weather.gov
                console.log('SEA CONDITIONS: Using NOAA marine forecast (same working domain as weather)');
                
                // Use forecast.weather.gov marine forecast for San Diego (PZZ740)
                const marineUrl = getMobileFallbackUrls('https://forecast.weather.gov/shmrn.php?mz=pzz740&syn=pzz700');
                
                console.log('SEA CONDITIONS DEBUG: NOAA marine forecast URL:', marineUrl);
                
                // Try marine forecast data
                console.log('SEA CONDITIONS DEBUG: Attempting NOAA marine forecast');
                const marineResponse = await fetchWithTimeout(marineUrl, 12000);
                
                if (!marineResponse.ok) {
                    throw new Error(`Marine forecast HTTP ${marineResponse.status}`);
                }
                
                const marineText = await marineResponse.text();
                console.log('SEA CONDITIONS DEBUG: Marine forecast length:', marineText.length);
                console.log('SEA CONDITIONS DEBUG: Marine forecast sample:', marineText.substring(0, 500));
                
                const marineData = parseMarineForecastText(marineText);
                if (!marineData) {
                    throw new Error('Failed to parse marine forecast');
                }
                
                // Update source display
                updateElement('buoy-source', 'NOAA Marine Forecast (PZZ740)');
                
                // Update display with marine forecast data
                updateSeaConditionsFromMarineForecast(marineData);
                
                
            } catch (error) {
                console.log('SEA CONDITIONS: NOAA marine forecast failed with error:', error.message);
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log('SEA CONDITIONS: This should work - using same forecast.weather.gov domain');
                
                // Provide honest, specific error messages
                let errorText;
                if (isMobile) {
                    if (error.message.includes('CORS') || error.message.includes('blocked')) {
                        errorText = 'CORS Blocked';
                    } else {
                        errorText = 'Mobile Network Issue';
                    }
                } else {
                    errorText = 'Unavailable';
                }
                
                console.log('SEA CONDITIONS: Showing error status:', errorText);
                updateElement('wave-height', errorText);
                updateElement('wave-period', errorText);
                updateElement('water-temp', errorText);
                updateElement('swell-height', errorText);
                updateElement('swell-period', errorText);
                updateElement('swell-direction', errorText);
                updateElement('buoy-source', isMobile ? 'Marine Forecast (CORS Blocked)' : 'Unavailable');
            }
        }

        // Fetch NOAA surface and tidal currents data - Enhanced with tide-based estimation
        async function fetchCurrentsData() {
            try {
                console.log('SURFACE CURRENTS: Starting with enhanced tide-based approach');
                
                // Skip the failing product=currents API entirely
                // Instead, use working tide data to estimate currents (more reliable)
                console.log('SURFACE CURRENTS: Using working tides API to estimate currents (bypass CORS blocked product=currents)');
                
                const currentDate = new Date().toISOString().split('T')[0].replace(/-/g, '');
                const tidesUrl = getMobileFallbackUrls(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${currentDate}&end_date=${currentDate}&station=9410170&product=predictions&datum=mllw&units=english&time_zone=lst_ldt&format=json`);
                
                const response = await fetchWithTimeout(tidesUrl);
                console.log('SURFACE CURRENTS DEBUG: Fetch completed without throwing error');
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('SURFACE CURRENTS DEBUG: Using working tides data to estimate currents');
                    console.log('SURFACE CURRENTS DEBUG: Tides data structure:', Object.keys(data));
                    
                    if (data.predictions && data.predictions.length > 0) {
                        console.log('SURFACE CURRENTS DEBUG: Found', data.predictions.length, 'tide predictions');
                        
                        // Find current tide state and next tide change
                        const now = new Date();
                        const currentTime = now.toISOString();
                        
                        let currentTide = null;
                        let nextTide = null;
                        
                        for (let i = 0; i < data.predictions.length - 1; i++) {
                            const tideTime = new Date(data.predictions[i].t);
                            const nextTideTime = new Date(data.predictions[i + 1].t);
                            
                            if (tideTime <= now && nextTideTime >= now) {
                                currentTide = data.predictions[i];
                                nextTide = data.predictions[i + 1];
                                break;
                            }
                        }
                        
                        if (currentTide && nextTide) {
                            const currentHeight = parseFloat(currentTide.v);
                            const nextHeight = parseFloat(nextTide.v);
                            const heightDiff = nextHeight - currentHeight;
                            
                            // Estimate current speed based on tide change rate
                            const timeToNext = (new Date(nextTide.t) - now) / (1000 * 60 * 60); // Hours
                            const estimatedSpeed = Math.abs(heightDiff) * 0.8; // Rough conversion factor
                            
                            // Determine direction (flood vs ebb)
                            const isRising = heightDiff > 0;
                            const direction = isRising ? 45 : 225; // NE for flood, SW for ebb (San Diego Bay pattern)
                            
                            // Update display
                            updateElement('current-speed', estimatedSpeed.toFixed(1) + ' kts (est)');
                            
                            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                            const index = Math.round(direction / 22.5) % 16;
                            updateElement('current-direction', directions[index] + ' (' + Math.round(direction) + '¬∞)');
                            
                            // Tidal current type
                            const tidalCurrent = estimatedSpeed > 0.3 ? (isRising ? 'Flood' : 'Ebb') : 'Slack';
                            updateElement('tidal-current', tidalCurrent);
                            
                            console.log('SURFACE CURRENTS DEBUG: Estimated from tides - Speed:', estimatedSpeed, 'Direction:', direction, 'Type:', tidalCurrent);
                        } else {
                            throw new Error('Could not find current tide position');
                        }
                        
                    } else {
                        console.log('SURFACE CURRENTS DEBUG: No tide predictions in data');
                        throw new Error('No tide data for current estimation');
                    }
                } else {
                    console.log('SURFACE CURRENTS DEBUG: HTTP Response not OK - Status:', response.status, response.statusText);
                    throw new Error(`Tides API HTTP ${response.status}`);
                }
                
            } catch (error) {
                console.log('SURFACE CURRENTS: Tide-based estimation failed with error:', error.message);
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log('SURFACE CURRENTS: This approach uses the SAME working tides API, so should succeed');
                
                // If even the working tides API fails, show appropriate error
                if (isMobile && (error.message.includes('CORS') || error.message.includes('blocked'))) {
                    updateElement('current-speed', 'CORS Blocked');
                    updateElement('current-direction', 'CORS Blocked');
                    updateElement('tidal-current', 'CORS Blocked');
                    return;
                }
                
                // Try alternative approach with general tidal flow estimation
                try {
                    // Get tide data to estimate tidal currents
                    const today = new Date().toISOString().split('T')[0].replace(/-/g, '');
                    const tidesUrl = getCorsProxyUrl(`https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?begin_date=${today}&end_date=${today}&station=9410170&product=predictions&datum=mllw&units=english&time_zone=lst_ldt&format=json`);
                    const tidesResponse = await fetch(tidesUrl);
                    
                    if (tidesResponse.ok) {
                        const tidesData = await tidesResponse.json();
                        if (tidesData.predictions && tidesData.predictions.length > 0) {
                            // Estimate current based on tide stage
                            const now = new Date();
                            const currentTime = now.toISOString();
                            
                            // Find closest tide prediction
                            let closestTide = tidesData.predictions[0];
                            let minDiff = Math.abs(new Date(closestTide.t) - now);
                            
                            for (const tide of tidesData.predictions) {
                                const diff = Math.abs(new Date(tide.t) - now);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    closestTide = tide;
                                }
                            }
                            
                            // Estimate current speed and direction based on tide
                            const height = parseFloat(closestTide.v);
                            const estimatedSpeed = Math.min(height * 0.3, 2.0); // Rough estimation
                            
                            updateElement('current-speed', `~${estimatedSpeed.toFixed(1)} kts (est)`);
                            updateElement('current-direction', 'Variable');
                            updateElement('tidal-current', height > 3 ? 'Flood (est)' : 'Ebb (est)');
                            
                        } else {
                            throw new Error('No tide data for estimation');
                        }
                    } else {
                        throw new Error('Cannot estimate currents');
                    }
                } catch (estError) {
                    updateElement('current-speed', 'No Data');
                    updateElement('current-direction', 'No Data');
                    updateElement('tidal-current', 'No Data');
                }
            }
        }

        // Fetch USGS earthquake data for San Diego area (100km radius, past 48hrs)
        async function fetchEarthquakeData() {
            try {
                
                const now = new Date();
                const twoDaysAgo = new Date(now.getTime() - (48 * 60 * 60 * 1000));
                const startTime = twoDaysAgo.toISOString();
                
                // Try alternative USGS endpoint or different proxy for earthquake data
                let earthquakeUrl, response;
                
                try {
                    // Primary: Use standard USGS API with CORS proxy
                    earthquakeUrl = getCorsProxyUrl(`https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${startTime}&latitude=32.7157&longitude=-117.1611&maxradiuskm=100&minmagnitude=2.0&orderby=time`);
                    console.log('EARTHQUAKE URL (Primary):', earthquakeUrl);
                    response = await fetch(earthquakeUrl);
                    
                    if (!response.ok) throw new Error('Primary earthquake URL failed');
                } catch (primaryError) {
                    // Fallback: Try allorigins as backup for earthquake data specifically
                    console.log('Primary earthquake fetch failed, trying backup...');
                    earthquakeUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${startTime}&latitude=32.7157&longitude=-117.1611&maxradiuskm=100&minmagnitude=2.0&orderby=time`)}`;
                    console.log('EARTHQUAKE URL (Backup):', earthquakeUrl);
                    response = await fetch(earthquakeUrl);
                    
                    if (!response.ok) throw new Error('Backup earthquake URL also failed');
                }
                
                const data = await response.json();
                const earthquakes = data.features || [];
                
                const container = document.getElementById('earthquake-container');
                if (container) {
                    if (earthquakes.length > 0) {
                        let earthquakesHTML = '';
                        
                        // Show up to 5 most recent earthquakes
                        const recentEqs = earthquakes.slice(0, 5);
                        
                        for (const eq of recentEqs) {
                            const props = eq.properties;
                            const coords = eq.geometry.coordinates;
                            
                            const magnitude = props.mag;
                            const place = props.place || 'Unknown location';
                            const time = new Date(props.time);
                            const depth = coords[2];
                            const distance = haversineDistance(32.7157, -117.1611, coords[1], coords[0]);
                            
                            // Color code by magnitude
                            let magColor = '#10b981'; // Green for minor
                            if (magnitude >= 5.0) magColor = '#ef4444'; // Red for moderate+
                            else if (magnitude >= 4.0) magColor = '#f59e0b'; // Orange for light
                            else if (magnitude >= 3.0) magColor = '#eab308'; // Yellow for minor
                            
                            const timeStr = time.toLocaleDateString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                            
                            earthquakesHTML += `
                                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.4); border-left: 3px solid ${magColor}; border-radius: 4px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                        <div style="font-weight: 600; color: ${magColor}; font-size: 0.9rem;">M${magnitude.toFixed(1)}</div>
                                        <div style="font-size: 0.7rem; color: #94a3b8;">${timeStr}</div>
                                    </div>
                                    <div style="font-size: 0.8rem; color: #cbd5e1; margin-bottom: 0.5rem;">${place}</div>
                                    <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #94a3b8;">
                                        <span>üìç ${distance.toFixed(0)}km away</span>
                                        <span>üï≥Ô∏è ${depth.toFixed(0)}km deep</span>
                                    </div>
                                </div>
                            `;
                        }
                        
                        container.innerHTML = earthquakesHTML;
                    } else {
                        container.innerHTML = '<div class="data-value">No earthquakes ‚â•M2.0 in past 48 hours</div>';
                    }
                }
                
                
            } catch (error) {
                const container = document.getElementById('earthquake-container');
                if (container) {
                    try {
                        container.innerHTML = '<div class="data-value" style="color: #ef4444;">USGS data unavailable</div>';
                    } catch (error) {
                        // Handle container update error
                    }
                }
            }
        }

        // Calculate distance between two coordinates using Haversine formula
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Fetch NOAA PTWC tsunami alert status
        async function fetchTsunamiAlerts() {
            try {
// Try to fetch from PTWC RSS feeds
                const tsunamiUrl = getCorsProxyUrl('https://www.tsunami.gov/events/PAAQ/2025/01/27/25027007/1/WEAK52/WEAK52.txt');
                const response = await fetch(tsunamiUrl);
                
                if (response.ok) {
                    const text = await response.text();
                    // Parse tsunami message text
                    if (text.toLowerCase().includes('no tsunami threat') || text.toLowerCase().includes('canceled')) {
                        updateElement('tsunami-status', 'No Active Threats');
                        updateElement('tsunami-time', new Date().toLocaleString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        }));
                    } else if (text.toLowerCase().includes('warning') || text.toLowerCase().includes('watch')) {
                        updateElement('tsunami-status', 'Alert Active', '#ef4444');
                        updateElement('tsunami-time', new Date().toLocaleString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        }));
                    }
                } else {
                    throw new Error('PTWC feed unavailable');
                }
                
            } catch (error) {
                // Default to monitoring status
                updateElement('tsunami-status', 'Monitoring Normal');
                updateElement('tsunami-time', new Date().toLocaleString('en-US', {
                    timeZone: 'America/Los_Angeles',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                }));
            }
        }

        // Calculate moon phase using astronomical calculation for PST
        function calculateMoonPhase() {
            // Use PST timezone for accurate moon phase calculation
            const now = new Date();
            const pstNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
            
            // Known new moon: August 4, 2025 (more recent reference for accuracy)
            const knownNewMoon = new Date('2025-08-04T00:00:00');
            const synodicMonth = 29.530588853; // days
            
            const daysSinceNewMoon = (pstNow - knownNewMoon) / (1000 * 60 * 60 * 24);
            const phase = (daysSinceNewMoon % synodicMonth) / synodicMonth;
            
            // Determine detailed phase name with descriptive terminology
            if (phase < 0.0625 || phase >= 0.9375) {
                return 'üåë New Moon (Dark)';
            } else if (phase < 0.125) {
                return 'üåí Waxing Crescent (Growing)';
            } else if (phase < 0.1875) {
                return 'üåí Waxing Crescent (Expanding)';
            } else if (phase < 0.25) {
                return 'üåì First Quarter (Half Full)';
            } else if (phase < 0.3125) {
                return 'üåì First Quarter (Waxing)';
            } else if (phase < 0.375) {
                return 'üåî Waxing Gibbous (Growing)';
            } else if (phase < 0.4375) {
                return 'üåî Waxing Gibbous (Nearly Full)';
            } else if (phase < 0.5) {
                return 'üåï Full Moon (Rising)';
            } else if (phase < 0.5625) {
                return 'üåï Full Moon (Bright)';
            } else if (phase < 0.625) {
                return 'üåñ Waning Gibbous (Shrinking)';
            } else if (phase < 0.6875) {
                return 'üåñ Waning Gibbous (Decreasing)';
            } else if (phase < 0.75) {
                return 'üåó Last Quarter (Half Dark)';
            } else if (phase < 0.8125) {
                return 'üåó Last Quarter (Waning)';
            } else if (phase < 0.875) {
                return 'üåò Waning Crescent (Shrinking)';
            } else {
                return 'üåò Waning Crescent (Nearly Dark)';
            }
        }

        // Fetch real weather alerts from NOAA
        async function fetchRealWeatherAlerts() {
            try {
                
// Get alerts for San Diego County (zone CAZ043) with mobile fallback
                const alertsUrl = getMobileFallbackUrls('https://api.weather.gov/alerts/active?zone=CAZ043');
                const response = await fetchWithTimeout(alertsUrl, 8000);
                
                if (!response.ok) throw new Error('Weather alerts API unavailable');
                
                const data = await response.json();
                const alerts = data.features;
                
                if (alerts && alerts.length > 0) {
                    // Find marine-related alerts
                    let marineAlert = null;
                    for (let alert of alerts) {
                        const event = alert.properties.event;
                        const headline = alert.properties.headline || '';
                        
                        if (event.includes('Marine') || event.includes('Small Craft') || 
                            event.includes('Gale') || event.includes('Storm') ||
                            headline.toLowerCase().includes('marine') || 
                            headline.toLowerCase().includes('coastal')) {
                            marineAlert = alert;
                            break;
                        }
                    }
                    
                    if (marineAlert) {
                        const props = marineAlert.properties;
                        updateElement('alert-title', props.event);
                        updateElement('alert-desc', props.headline || props.description || 'Active marine weather alert');
                        
                        if (props.expires) {
                            const expiresDate = new Date(props.expires);
                            const expiresTime = expiresDate.toLocaleString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                month: 'short',
                                day: 'numeric',
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: false
                            });
                            updateElement('alert-time', 'Until: ' + expiresTime);
                        }
                        
                        // Color code based on severity
                        const severity = props.severity;
                        const alertColor = severity === 'Severe' ? '#ef4444' : 
                                          severity === 'Moderate' ? '#f59e0b' : '#10b981';
                        document.getElementById('alert-title').style.color = alertColor;
                    } else {
                        // No marine alerts, check for general alerts
                        if (alerts.length > 0) {
                            const firstAlert = alerts[0].properties;
                            updateElement('alert-title', firstAlert.event);
                            updateElement('alert-desc', firstAlert.headline || 'Active weather alert');
                            const pstTime = new Date().toLocaleTimeString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: false
                            });
                            updateElement('alert-time', 'Updated: ' + pstTime + ' PST');
                        } else {
                            updateElement('alert-title', 'No Active Alerts');
                            updateElement('alert-desc', 'No weather warnings currently issued for San Diego area');
                            const pstTime = new Date().toLocaleTimeString('en-US', {
                                timeZone: 'America/Los_Angeles',
                                hour: 'numeric',
                                minute: '2-digit',
                                hour12: false
                            });
                            updateElement('alert-time', 'Last checked: ' + pstTime + ' PST');
                            document.getElementById('alert-title').style.color = '#10b981';
                        }
                    }
                } else {
                    updateElement('alert-title', 'No Active Alerts');
                    updateElement('alert-desc', 'No weather warnings currently issued for San Diego area');
                    updateElement('alert-time', 'Last checked: ' + new Date().toLocaleTimeString('en-US', {
                        timeZone: 'America/Los_Angeles',
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit'
                    }) + ' PST');
                    document.getElementById('alert-title').style.color = '#10b981';
                }
                
                
            } catch (error) {
                updateElement('alert-title', 'Alert System Offline');
                updateElement('alert-desc', 'Unable to connect to NOAA Weather Alert system');
                updateElement('alert-time', 'Check connection');
                document.getElementById('alert-title').style.color = '#6b7280';
            }
        }

        // Fetch real-time astronomical data
        async function fetchRealAstronomicalData() {
            try {
                console.log('ASTRONOMICAL DEBUG: Starting fetch');
                
                // Use sunrise-sunset.org API for San Diego coordinates
                const lat = 32.7157;  // San Diego latitude
                const lng = -117.1611; // San Diego longitude
                const today = new Date().toISOString().split('T')[0];
                
                const sunriseUrl = getMobileFallbackUrls(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lng}&date=${today}&formatted=0`);
                console.log('ASTRONOMICAL DEBUG: URL generated:', sunriseUrl);
                
                const response = await fetchWithTimeout(sunriseUrl);
                console.log('ASTRONOMICAL DEBUG: Response received, status:', response.status);
                console.log('ASTRONOMICAL DEBUG: Response headers:', [...response.headers.entries()]);
                
                const responseText = await response.text();
                console.log('ASTRONOMICAL DEBUG: Raw response text:', responseText.substring(0, 200));
                
                let data;
                try {
                    data = JSON.parse(responseText);
                    console.log('ASTRONOMICAL DEBUG: Parsed JSON:', data);
                } catch (parseError) {
                    console.error('ASTRONOMICAL DEBUG: JSON parse failed:', parseError);
                    console.log('ASTRONOMICAL DEBUG: Full response text:', responseText);
                    throw new Error('Failed to parse astronomical data JSON');
                }
                
                if (data.status === 'OK') {
                    const results = data.results;
                    
                    // Convert UTC time to PST/PDT (24-hour format)
                    const convertToPST24 = (utcTime) => {
                        const date = new Date(utcTime);
                        return date.toLocaleTimeString('en-US', { 
                            timeZone: 'America/Los_Angeles',
                            hour12: false, 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    };
                    
                    updateElement('twilight-begin', convertToPST24(results.nautical_twilight_begin));
                    updateElement('twilight-end', convertToPST24(results.nautical_twilight_end));
                } else {
                    // API failed, show error
                    updateElement('twilight-begin', 'API Error');
                    updateElement('twilight-end', 'API Error');
                }
                
                // Calculate moon phase directly with proper illumination
                const moonPhase = calculateMoonPhase();
                updateElement('moon-phase', moonPhase);
                
                // Calculate moon illumination percentage
                const now = new Date();
                const knownNewMoon = new Date('2025-08-04T11:13:00Z');
                const daysSinceNewMoon = (now - knownNewMoon) / (24 * 60 * 60 * 1000);
                const lunarCycle = 29.530588853;
                const phase = ((daysSinceNewMoon % lunarCycle) + lunarCycle) % lunarCycle / lunarCycle;
                
                let illumination;
                if (phase <= 0.5) {
                    illumination = phase * 2 * 100;
                } else {
                    illumination = (1 - phase) * 2 * 100;
                }
                
                const illuminationPercent = Math.round(Math.max(0, Math.min(100, illumination)));
                updateElement('moon-illumination', illuminationPercent + '%');
                
                // Set visibility based on moon illumination
                const visibilityCondition = illuminationPercent > 70 ? 'Excellent' :
                                            illuminationPercent > 50 ? 'Good' :
                                            illuminationPercent > 25 ? 'Fair' : 'Poor';
                const visibilityColor = illuminationPercent > 70 ? '#10b981' :
                                       illuminationPercent > 50 ? '#10b981' :
                                       illuminationPercent > 25 ? '#f59e0b' : '#ef4444';
                
                updateElement('visibility-conditions', visibilityCondition, visibilityColor);
                
                
            } catch (error) {
                console.error('ASTRONOMICAL ERROR:', error.message);
                
                // Fallback to approximate sunrise/sunset times for San Diego
                const today = new Date();
                const month = today.getMonth() + 1;
                
                // Approximate times for San Diego by season
                let sunriseApprox, sunsetApprox;
                if (month >= 3 && month <= 5) { // Spring
                    sunriseApprox = "06:15";
                    sunsetApprox = "19:30";
                } else if (month >= 6 && month <= 8) { // Summer
                    sunriseApprox = "05:50";
                    sunsetApprox = "20:00";
                } else if (month >= 9 && month <= 11) { // Fall
                    sunriseApprox = "06:30";
                    sunsetApprox = "18:30";
                } else { // Winter
                    sunriseApprox = "06:50";
                    sunsetApprox = "17:00";
                }
                
                updateElement('sunrise-time', sunriseApprox + ' PST (approx)');
                updateElement('sunset-time', sunsetApprox + ' PST (approx)');
                updateElement('moon-phase', calculateMoonPhase()); // Moon phase calculation still works
                updateElement('twilight-begin', 'API Offline');
                updateElement('twilight-end', 'API Offline');
                updateElement('moon-illumination', 'API Offline');
                updateElement('visibility-conditions', 'Unknown');
            }
        }


        // Fetch real-time USCG maritime notices from RSS feed
        async function fetchRealNotices() {
            try {
// Use real USCG Sector San Diego RSS feed with CORS proxy if needed
                const uscgRssUrl = getCorsProxyUrl('https://public.govdelivery.com/topics/USDHSCG_436/feed.rss');
                
                const response = await fetch(uscgRssUrl);
                
                if (!response.ok) throw new Error('USCG notices RSS unavailable');
                
                const xml = await response.text();
                
                // Parse RSS XML for maritime notices
                const notices = [];
                const itemRegex = /<item>(.*?)<\/item>/gs;
                const titleRegex = /<title><!\[CDATA\[(.*?)\]\]><\/title>/s;
                const descRegex = /<description><!\[CDATA\[(.*?)\]\]><\/description>/s;
                const pubDateRegex = /<pubDate>(.*?)<\/pubDate>/s;
                
                let match;
                let totalItemsFound = 0;
                while ((match = itemRegex.exec(xml)) !== null && notices.length < 5) {
                    totalItemsFound++;
                    const item = match[1];
                    const titleMatch = titleRegex.exec(item);
                    const descMatch = descRegex.exec(item);
                    const dateMatch = pubDateRegex.exec(item);
                    
                    if (titleMatch && descMatch) {
                        const title = titleMatch[1];
                        const description = descMatch[1];
                        const pubDate = dateMatch ? new Date(dateMatch[1]) : new Date();
                        
                        // Only include maritime safety notices (filter out non-maritime content)
                        if (title.toLowerCase().includes('safety') || 
                            title.toLowerCase().includes('hazard') ||
                            title.toLowerCase().includes('haz ops') ||
                            title.toLowerCase().includes('diving') ||
                            title.toLowerCase().includes('military') ||
                            title.toLowerCase().includes('aton') ||
                            title.toLowerCase().includes('detonation') ||
                            title.toLowerCase().includes('imperial beach') ||
                            title.toLowerCase().includes('southern california') ||
                            description.toLowerCase().includes('mariner') ||
                            description.toLowerCase().includes('underwater detonation') ||
                            description.toLowerCase().includes('hazardous operations')) {
                            
                            notices.push({
                                title: title,
                                description: description.length > 200 ? description.substring(0, 200) + '...' : description,
                                pubDate: pubDate.toLocaleDateString('en-US', {
                                    timeZone: 'America/Los_Angeles',
                                    month: 'short',
                                    day: 'numeric'
                                }),
                                authority: "USCG Sector San Diego"
                            });
                        }
                    }
                }
                
                
                // Update notices display
                const noticesContainer = document.getElementById('notices-container');
                if (noticesContainer) {
                    if (notices.length > 0) {
                        let noticesHTML = '';
                        for (const notice of notices) {
                            noticesHTML += `
                                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.4); border-left: 3px solid #60a5fa; border-radius: 4px;">
                                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                                        <div style="font-weight: 600; color: #60a5fa; font-size: 0.85rem;">${notice.title}</div>
                                        <div style="font-size: 0.7rem; color: #94a3b8;">${notice.pubDate}</div>
                                    </div>
                                    <div style="font-size: 0.75rem; color: #cbd5e1; margin-bottom: 0.5rem; line-height: 1.3;">${notice.description}</div>
                                    <div style="font-size: 0.7rem; color: #94a3b8;">
                                        <span>üìç ${notice.authority}</span>
                                    </div>
                                </div>
                            `;
                        }
                        noticesContainer.innerHTML = noticesHTML;
                    } else {
                        // No notices available - show link only
                        noticesContainer.innerHTML = `
                            <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(15, 23, 42, 0.4); border-left: 3px solid #94a3b8; border-radius: 4px;">
                                <div style="font-weight: 600; color: #94a3b8; font-size: 0.85rem; margin-bottom: 0.5rem;">No current maritime safety notices</div>
                                <div style="font-size: 0.8rem; color: #94a3b8; line-height: 1.4;">
                                    Check: <a href="https://navcen.uscg.gov/local-notices-to-mariners?district=11+0&subdistrict=n" target="_blank" style="color: #60a5fa;">USCG District 11 LNM</a>
                                </div>
                            </div>
                        `;
                    }
                }
                
                
            } catch (error) {
                const noticesContainer = document.getElementById('notices-container');
                if (noticesContainer) {
                    noticesContainer.innerHTML = `
                        <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 4px;">
                            <div style="font-weight: 600; color: #ef4444; font-size: 0.85rem; margin-bottom: 0.5rem;">RSS Feed Unavailable</div>
                            <div style="font-size: 0.8rem; color: #94a3b8; line-height: 1.4;">
                                Check manually: <a href="https://navcen.uscg.gov/local-notices-to-mariners?district=11+0&subdistrict=n" target="_blank" style="color: #60a5fa;">USCG District 11 LNM</a>
                            </div>
                        </div>
                    `;
                }
            }
        }

        // Fetch real air quality data from EPA AirNow
        async function fetchRealAirQuality() {
            try {
                console.log('AIR QUALITY: Starting (working: weather/tides/astro, testing: airnowapi.org)');
                
                // EPA AirNow API endpoint for San Diego (zip code 92101) with mobile fallback
                const airQualityUrl = getMobileFallbackUrls(`https://www.airnowapi.org/aq/observation/zipCode/current/?format=application/json&API_KEY=64CC1372-9F33-4AA3-8788-9AB1C2AE9E12&zipCode=92101&distance=25`);
                console.log('AIR QUALITY: Trying EPA AirNow (different domain from working NOAA APIs)');
                
                const response = await fetchWithTimeout(airQualityUrl);
                console.log('AIR QUALITY DEBUG: HTTP Response status:', response.status, response.statusText);
                console.log('AIR QUALITY DEBUG: Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) throw new Error(`EPA AirNow API HTTP ${response.status}`);
                
                const responseText = await response.text();
                console.log('AIR QUALITY DEBUG: Raw response text (first 500 chars):', responseText.substring(0, 500));
                console.log('AIR QUALITY DEBUG: Response text length:', responseText.length);
                
                let data;
                try {
                    data = JSON.parse(responseText);
                    console.log('AIR QUALITY DEBUG: JSON parse successful');
                } catch (parseError) {
                    console.log('AIR QUALITY DEBUG: JSON parse failed:', parseError.message);
                    console.log('AIR QUALITY DEBUG: Response might not be JSON:', responseText);
                    throw new Error('Invalid JSON response');
                }
                
                console.log('AIR QUALITY DEBUG: Response data:', data);
                console.log('AIR QUALITY DEBUG: Data length:', data?.length);
                
                if (data && data.length > 0) {
                    console.log('AIR QUALITY DEBUG: Found', data.length, 'readings');
                    console.log('AIR QUALITY DEBUG: First reading structure:', Object.keys(data[0]));
                    console.log('AIR QUALITY DEBUG: Sample reading data:', JSON.stringify(data[0], null, 2));
                    
                    // Get the primary pollutant with highest AQI
                    let primaryData = data[0];
                    for (const reading of data) {
                        if (reading.AQI > primaryData.AQI) {
                            primaryData = reading;
                        }
                    }
                    
                    console.log('AIR QUALITY DEBUG: Primary data selected:', JSON.stringify(primaryData, null, 2));
                    
                    // Update AQI index
                    const aqiIndex = document.getElementById('aqi-index');
                    if (aqiIndex) {
                        const aqiValue = primaryData.AQI;
                        let aqiColor = '#10b981'; // Good (green)
                        if (aqiValue > 150) aqiColor = '#dc2626'; // Unhealthy (red)
                        else if (aqiValue > 100) aqiColor = '#ea580c'; // Unhealthy for Sensitive Groups (orange)
                        else if (aqiValue > 50) aqiColor = '#eab308'; // Moderate (yellow)
                        
                        aqiIndex.innerHTML = `<span style="color: ${aqiColor}; font-weight: bold;">${aqiValue}</span>`;
                    }
                    
                    // Update primary pollutant
                    const aqiPollutant = document.getElementById('aqi-pollutant');
                    if (aqiPollutant) {
                        aqiPollutant.textContent = primaryData.ParameterName || 'Unknown';
                    }
                    
                    // Update health category
                    const aqiCategory = document.getElementById('aqi-category');
                    if (aqiCategory) {
                        let category = 'Good';
                        if (primaryData.AQI > 150) category = 'Unhealthy';
                        else if (primaryData.AQI > 100) category = 'Unhealthy for Sensitive Groups';
                        else if (primaryData.AQI > 50) category = 'Moderate';
                        
                        aqiCategory.textContent = category;
                    }
                    
                    // Update last updated time
                    const aqiTime = document.getElementById('aqi-time');
                    if (aqiTime && primaryData.DateObserved && primaryData.HourObserved >= 0) {
                        const dateStr = primaryData.DateObserved;
                        const hour = String(primaryData.HourObserved).padStart(2, '0');
                        const observationDate = new Date(`${dateStr} ${hour}:00:00 PST`);
                        
                        aqiTime.textContent = observationDate.toLocaleTimeString('en-US', {
                            timeZone: 'America/Los_Angeles',
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit'
                        }) + ' PST';
                    }
                    
                } else {
                    console.log('AIR QUALITY DEBUG: Data check failed - data:', data);
                    console.log('AIR QUALITY DEBUG: Data type:', typeof data);
                    console.log('AIR QUALITY DEBUG: Data is array:', Array.isArray(data));
                    console.log('AIR QUALITY DEBUG: Data length check:', data ? data.length : 'data is falsy');
                    throw new Error('No air quality data available');
                }
                
            } catch (error) {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const errorText = isMobile ? 'Mobile Network Issue' : 'Unavailable';
                
                const aqiIndex = document.getElementById('aqi-index');
                const aqiPollutant = document.getElementById('aqi-pollutant');
                const aqiCategory = document.getElementById('aqi-category');
                const aqiTime = document.getElementById('aqi-time');
                
                if (aqiIndex) aqiIndex.textContent = errorText;
                if (aqiPollutant) aqiPollutant.textContent = errorText;
                if (aqiCategory) aqiCategory.textContent = errorText;
                if (aqiTime) aqiTime.textContent = errorText;
            }
        }

        // Update all real-time data with comprehensive error handling
        async function updateAllRealTime() {
            try {
            console.log('UPDATE DEBUG: Starting updateAllRealTime()');
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log('UPDATE DEBUG: Mobile device detected:', isMobile);
            
            updateTime();
            
            // For mobile, load APIs one at a time to make debugging readable
            if (isMobile) {
                console.log('UPDATE DEBUG: Loading mobile APIs sequentially for better debugging');
                
                console.log('MOBILE SEQUENCE: 1/11 - Loading Weather...');
                await fetchRealWeatherData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 2/11 - Loading Astronomical...');
                await fetchRealAstronomicalData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 3/11 - Loading Tides...');
                await fetchRealTideData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 4/11 - Loading Sea Conditions...');
                await fetchRealSeaData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 5/11 - Loading Air Quality...');
                await fetchRealAirQuality().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 6/11 - Loading Surface Currents...');
                await fetchCurrentsData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 7/11 - Loading Weather Forecast...');
                await fetchWeatherForecast().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 8/11 - Loading Earthquake Data...');
                await fetchEarthquakeData().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 9/11 - Loading Tsunami Alerts...');
                await fetchTsunamiAlerts().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 10/11 - Loading USCG Notices...');
                await fetchRealNotices().catch(() => {});
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('MOBILE SEQUENCE: 11/11 - Loading Weather Alerts...');
                await fetchRealWeatherAlerts().catch(() => {});
                
                console.log('MOBILE DEBUG: Completed sequential loading - check results above');
            } else {
                // Desktop - load all APIs simultaneously
                console.log('UPDATE DEBUG: Starting Promise.allSettled for all APIs');
                const results = await Promise.allSettled([
                    fetchRealWeatherData(),
                    fetchWeatherForecast(),
                    fetchRealTideData(), 
                    fetchRealSeaData(),
                    fetchCurrentsData(),
                    fetchEarthquakeData(),
                    fetchTsunamiAlerts(),
                    fetchRealAstronomicalData(),
                    fetchRealNotices(),
                    fetchRealAirQuality(),
                    fetchRealWeatherAlerts()
                ]);
                
                console.log('UPDATE DEBUG: API results summary:');
                const apiNames = ['Weather', 'Forecast', 'Tides', 'Sea', 'Currents', 'Earthquake', 'Tsunami', 'Astronomical', 'Notices', 'AirQuality', 'WeatherAlerts'];
                results.forEach((result, index) => {
                    console.log(`UPDATE DEBUG: ${apiNames[index]} - ${result.status}`, result.status === 'rejected' ? result.reason?.message : 'Success');
                });
            }
            
            } catch (error) {
                console.error('UPDATE CYCLE ERROR:', error);
            }
        }

        // ERROR DEBUGGING - Log all errors to console for troubleshooting
        window.addEventListener('error', function(e) {
            console.error('GLOBAL ERROR:', e.error, 'at', e.filename + ':' + e.lineno);
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('UNHANDLED PROMISE REJECTION:', e.reason);
        });
        
        // MOBILE DEBUGGING - Detect mobile and add specific debugging
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            console.log('MOBILE DEVICE DETECTED:', navigator.userAgent);
        }

        // Initialize the system with error handling
        try {
            console.log('INIT: Starting system initialization...');
            
            // Start real-time data updates immediately and then every 30 seconds
            setTimeout(updateAllRealTime, 1000); // Start after 1 second
            setInterval(updateAllRealTime, 30000); // Every 30 seconds
            
            // Update time every second
            setInterval(updateTime, 1000);
            
            console.log('INIT: System initialization complete');
        } catch (error) {
            console.error('INIT ERROR:', error);
        }
    </script>

    <!-- Mobile Debug Panel (only visible on mobile) -->
    <div id="mobile-debug-panel" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.95); color: #00ff00; font-family: monospace; font-size: 10px; padding: 10px; max-height: 250px; overflow-y: auto; border-top: 2px solid #00ff00; z-index: 9999;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 5px;">
            <span style="color: #ff6600; font-weight: bold;">üì± MOBILE DEBUG CONSOLE</span>
            <div style="display: flex; gap: 5px;">
                <button id="pause-debug-btn" onclick="toggleDebugPause()" style="background: #ff6600; color: #fff; border: 1px solid #666; padding: 2px 8px; font-size: 10px; cursor: pointer;">PAUSE</button>
                <button onclick="clearDebugOutput()" style="background: #666; color: #fff; border: 1px solid #666; padding: 2px 8px; font-size: 10px; cursor: pointer;">CLEAR</button>
                <button onclick="toggleDebugPanel()" style="background: #333; color: #fff; border: 1px solid #666; padding: 2px 8px; font-size: 10px; cursor: pointer;">HIDE</button>
            </div>
        </div>
        <div id="debug-output" style="white-space: pre-wrap; line-height: 1.2;"></div>
    </div>

    <!-- Debug Toggle Button -->
    <div id="debug-toggle" style="display: none; position: fixed; top: 10px; right: 10px; background: rgba(255,102,0,0.8); color: white; padding: 8px 12px; border-radius: 20px; font-size: 12px; font-weight: bold; cursor: pointer; z-index: 10000; border: 2px solid #ff6600;" onclick="toggleDebugPanel()">
        üêõ DEBUG
    </div>

    <script>
        // Mobile debug logging system
        let debugMessages = [];
        const maxDebugMessages = 50;
        let debugPaused = false;

        // Override console.log for mobile debugging
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;

        function addDebugMessage(type, ...args) {
            // Don't add messages when paused
            if (debugPaused) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
            
            debugMessages.push({
                time: timestamp,
                type: type,
                message: message
            });

            // Keep only the last maxDebugMessages
            if (debugMessages.length > maxDebugMessages) {
                debugMessages = debugMessages.slice(-maxDebugMessages);
            }

            updateDebugDisplay();
        }

        // Override console methods for mobile debugging
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            addDebugMessage('LOG', ...args);
        };

        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            addDebugMessage('ERR', ...args);
        };

        console.warn = function(...args) {
            originalConsoleWarn.apply(console, args);
            addDebugMessage('WARN', ...args);
        };

        function updateDebugDisplay() {
            const debugOutput = document.getElementById('debug-output');
            if (debugOutput) {
                const displayMessages = debugMessages.slice(-20); // Show last 20 messages
                debugOutput.textContent = displayMessages.map(msg => 
                    `[${msg.time}] ${msg.type}: ${msg.message}`
                ).join('\n');
                
                // Auto-scroll to bottom
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
        }

        function toggleDebugPanel() {
            const panel = document.getElementById('mobile-debug-panel');
            const toggle = document.getElementById('debug-toggle');
            
            if (panel.style.display === 'none' || !panel.style.display) {
                panel.style.display = 'block';
                toggle.style.display = 'none';
            } else {
                panel.style.display = 'none';
                toggle.style.display = 'block';
            }
        }

        function toggleDebugPause() {
            debugPaused = !debugPaused;
            const pauseBtn = document.getElementById('pause-debug-btn');
            if (debugPaused) {
                pauseBtn.textContent = 'RESUME';
                pauseBtn.style.background = '#10b981';
                console.log('DEBUG PAUSED - Click RESUME to continue logging');
            } else {
                pauseBtn.textContent = 'PAUSE';
                pauseBtn.style.background = '#ff6600';
                console.log('DEBUG RESUMED - Logging will continue');
            }
        }

        function clearDebugOutput() {
            debugMessages = [];
            updateDebugDisplay();
            console.log('DEBUG CLEARED - Fresh start');
        }

        // Show debug controls only on mobile
        function initMobileDebug() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('debug-toggle').style.display = 'block';
                console.log('MOBILE DEBUG: Debug panel initialized for mobile device');
                console.log('MOBILE DEBUG: User Agent:', navigator.userAgent);
                console.log('MOBILE DEBUG: Location:', window.location.href);
            }
        }

        // Initialize debug panel
        document.addEventListener('DOMContentLoaded', function() {
            initMobileDebug();
        });
    </script>

</body>
</html>